#!/usr/bin/env python3
import sys
import argparse
import json
import subprocess
import os
import signal
import time
import shutil
import re
import urllib.parse
import getpass
import platform
from pathlib import Path
from typing import Any, Optional, Dict

try:
    import termios
except Exception:
    termios = None  # type: ignore

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from agency.scout import Scout, ScoutConfig
from agency.lab_control import LabStateStore
from agency.process_utils import pid_running

try:
    from agency.crystallization import CrystallizationEngine, CrystallizationError
except Exception:
    CrystallizationEngine = None  # type: ignore
    CrystallizationError = RuntimeError  # type: ignore
try:
    from agency.voice import Voice
except Exception:
    Voice = None  # type: ignore
try:
    from agency.inspector import Inspector
except Exception:
    Inspector = None  # type: ignore
try:
    from agency.agentic_loop import AgentConstraints, run_agentic_session
except Exception:
    AgentConstraints = None  # type: ignore
    run_agentic_session = None  # type: ignore
try:
    from agency.tool_inventory import (
        load_inventory,
        get_tool_status,
        load_heartbeat_snapshot,
        load_tool_use_notes,
    )
except Exception:
    load_inventory = None  # type: ignore
    get_tool_status = None  # type: ignore
    load_heartbeat_snapshot = None  # type: ignore
    load_tool_use_notes = None  # type: ignore
try:
    from agency.motivo_vital import compute_motivo_vital, persist_mv
except Exception:
    compute_motivo_vital = None  # type: ignore
    persist_mv = None  # type: ignore
try:
    from agency.desktop_snap import capture_desktop_snapshot, list_local_displays
except Exception:
    capture_desktop_snapshot = None  # type: ignore
    list_local_displays = None  # type: ignore
try:
    from agency.display_targets import load_display_map, resolve_display_selection, save_display_map, fetch_driver_displays
except Exception:
    load_display_map = None  # type: ignore
    resolve_display_selection = None  # type: ignore
    save_display_map = None  # type: ignore
    fetch_driver_displays = None  # type: ignore
try:
    from agency.human_permission import grant_human_permission, read_human_permission_status
except Exception:
    grant_human_permission = None  # type: ignore
    read_human_permission_status = None  # type: ignore
try:
    from agency.jit_permit import evaluate_jit_permit, confirm_jit_permit
except Exception:
    evaluate_jit_permit = None  # type: ignore
    confirm_jit_permit = None  # type: ignore
try:
    from agency.lab_snap import capture_lab_snapshot, fetch_lab_driver_capabilities
except Exception:
    capture_lab_snapshot = None  # type: ignore
    fetch_lab_driver_capabilities = None  # type: ignore
try:
    from agency.driver_keys import load_ajax_driver_api_key
except Exception:
    load_ajax_driver_api_key = None  # type: ignore
try:
    from agency.windows_driver_client import _normalize_driver_path
except Exception:
    _normalize_driver_path = None  # type: ignore
try:
    from ui.concierge import Concierge, ConciergeState
except Exception:
    Concierge = None  # type: ignore
    ConciergeState = None  # type: ignore
try:
    from ui.session_state import list_waiting_missions
except Exception:
    list_waiting_missions = None  # type: ignore


import unicodedata
import contextlib

import requests  # type: ignore
from agency.leann_query_client import query_leann  # type: ignore
from agency.lab_control import LabStateStore, DEFAULT_PROBE_TTL_SECONDS

# ... (existing imports)

@contextlib.contextmanager
def silence_low_level():
    """Silencia descriptores de archivo 1 y 2 (stdout/stderr) a nivel de sistema."""
    # Solo silenciamos si estamos en modo user y no hay debug explícito
    debug = (os.getenv("AJAX_CHAT_DEBUG") or "0") == "1"
    if _ux_profile() == "user" and not debug:
        try:
            null_fd = os.open(os.devnull, os.O_RDWR)
            save_stdout = os.dup(1)
            # No silenciamos stderr para no ocultar fallos reales graves
            os.dup2(null_fd, 1)
            try:
                yield
            finally:
                sys.stdout.flush()
                os.dup2(save_stdout, 1)
                os.close(null_fd)
                os.close(save_stdout)
        except Exception:
            yield
    else:
        yield


def _load_env_file(path: Path) -> None:
    """Carga variables de un .env sencillo (key=value) si no están ya en el entorno."""
    if not path.exists():
        return
    for line in path.read_text(encoding="utf-8").splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#") or "=" not in stripped:
            continue
        key, val = stripped.split("=", 1)
        key = key.strip()
        val = val.strip().strip('"').strip("'")
        if key and key not in os.environ:
            os.environ[key] = val


# Auto-cargar .env (p.ej. GROQ_API_KEY) antes de inicializar AjaxCore o tareas
_load_env_file(ROOT / ".env")

AUTO_CRYSTALLIZE_FLAG = ROOT / "artifacts" / "state" / "auto_crystallize.flag"


def _get_core():
    try:
        import ajax
    except Exception as exc:  # pragma: no cover - depends on optional deps
        raise RuntimeError(f"AjaxCore no disponible: {exc}") from exc
    with silence_low_level():
        return ajax.wake_up()


def _get_chat_lite():
    try:
        import ajax
    except Exception as exc:  # pragma: no cover - depends on optional deps
        raise RuntimeError(f"AjaxChatLite no disponible: {exc}") from exc
    return ajax.wake_up_chat_lite()


def _is_wsl() -> bool:
    return bool(os.getenv("WSL_DISTRO_NAME") or "microsoft" in platform.release().lower())


def _is_interactive() -> bool:
    try:
        return sys.stdin.isatty() and sys.stdout.isatty()
    except Exception:
        return False


def _read_human_active_flag(root_dir: Path) -> Optional[bool]:
    paths = [
        root_dir / "state" / "human_active.flag",
        root_dir / "artifacts" / "state" / "human_active.flag",
        root_dir / "artifacts" / "policy" / "human_active.flag",
    ]
    for path in paths:
        try:
            if not path.exists():
                continue
            raw = path.read_text(encoding="utf-8").strip()
            if not raw:
                continue
            if raw.startswith("{"):
                try:
                    data = json.loads(raw)
                    if isinstance(data, dict) and "human_active" in data:
                        return bool(data.get("human_active"))
                except Exception:
                    pass
            lowered = raw.lower()
            if "true" in lowered:
                return True
            if "false" in lowered:
                return False
        except Exception:
            continue
    return None


def _default_cost_mode(root_dir: Path) -> str:
    human_active = _read_human_active_flag(root_dir)
    if human_active is True:
        return "save_codex"
    return "premium"


def _write_chat_perf_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        metrics_dir = root_dir / "artifacts" / "metrics"
        metrics_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = metrics_dir / f"chat_perf_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _write_exec_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        receipt_dir = root_dir / "artifacts" / "receipts"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = receipt_dir / f"exec_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _write_chat_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        receipt_dir = root_dir / "artifacts" / "receipts"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = receipt_dir / f"chat_event_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _write_git_status_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        receipt_dir = root_dir / "artifacts" / "receipts"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = receipt_dir / f"git_status_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _parse_bracket_command(line: str) -> tuple[Optional[str], str]:
    if line is None:
        return None, ""
    match = re.match(r"^\s*\[(?P<cmd>[^\]]+)\]\s*(?P<arg>.*)$", str(line))
    if not match:
        return None, str(line).strip()
    cmd = match.group("cmd").strip().lower()
    arg = (match.group("arg") or "").strip()
    return cmd, arg


def _waiting_enter_behavior() -> str:
    raw = str(os.getenv("AJAX_WAITING_ENTER_DEFAULT") or "").strip().lower()
    if raw in {"1", "true", "yes", "on"}:
        return "default"
    return "disabled"


def _chat_start_mode() -> str:
    raw = (
        (os.getenv("AJAX_CHAT_START_MODE") or os.getenv("AJAX_START_MODE") or "chat")
        .strip()
        .lower()
    )
    if raw in {"mission", "wait", "waiting"}:
        return "mission"
    return "chat"


def _pending_mission_policy() -> str:
    raw = (
        os.getenv("AJAX_PENDING_MISSION_POLICY")
        or os.getenv("AJAX_CHAT_PENDING_MISSION_POLICY")
        or "summarize_and_offer_switch"
    )
    return str(raw).strip().lower()


def _concierge_tone() -> str:
    raw = (
        (os.getenv("AJAX_CONCIERGE_TONE") or os.getenv("AJAX_CHAT_TONE") or "neutral")
        .strip()
        .lower()
    )
    return raw or "neutral"


def _concierge_mode() -> str:
    raw = (os.getenv("AJAX_CONCIERGE_MODE") or "heuristic").strip().lower()
    if raw == "local_llm":
        return "local_llm"
    return "heuristic"


def _parse_colon_command(line: str) -> tuple[Optional[str], str]:
    if line is None:
        return None, ""
    if not str(line).lstrip().startswith(":"):
        return None, str(line).strip()
    raw = str(line).lstrip()[1:]
    if not raw:
        return "", ""
    if " " in raw:
        cmd, arg = raw.split(" ", 1)
        return cmd.strip().lower(), (arg or "").strip()
    return raw.strip().lower(), ""


def _truncate_answer(text: str, limit: int = 240) -> str:
    txt = (text or "").strip()
    if len(txt) <= limit:
        return txt
    return txt[: limit - 1] + "…"


def _write_jit_permit_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        receipt_dir = root_dir / "artifacts" / "governance"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = receipt_dir / f"permit_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _write_vision_error_receipt(root_dir: Path, payload: Dict[str, Any]) -> Optional[str]:
    try:
        receipt_dir = root_dir / "artifacts" / "receipts"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        out_path = receipt_dir / f"vision_error_{ts}.json"
        out_path.write_text(
            json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
        return str(out_path)
    except Exception:
        return None


def _infer_risk_level_from_intent(intent: str) -> str:
    try:
        from agency.ajax_core import AjaxCore

        return str(AjaxCore._infer_risk_level_from_intent(intent)).strip().lower()
    except Exception:
        return "medium"


def _risk_score_from_level(risk_level: str) -> float:
    rl = (risk_level or "medium").strip().lower()
    if rl == "low":
        return 0.2
    if rl == "high":
        return 0.8
    return 0.5


def _resolve_rail() -> str:
    return (
        str(os.getenv("AJAX_RAIL") or os.getenv("AJAX_ENV") or os.getenv("AJAX_MODE") or "lab")
        .strip()
        .lower()
    )


def _is_yes_response(text: str) -> bool:
    raw = (text or "").strip().lower()
    return raw in {"y", "yes", "si", "sí", "s"}


def _load_json_input(file_arg: Optional[str], inline_arg: Optional[str]) -> Optional[Any]:
    if file_arg:
        path = Path(file_arg)
        if not path.exists():
            raise FileNotFoundError(f"No existe el archivo {path}")
        return json.loads(path.read_text(encoding="utf-8"))
    if inline_arg:
        return json.loads(inline_arg)
    return None


def _read_json(path: Path) -> Optional[Any]:
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None


def _lab_worker_paths(root: Path) -> tuple[Path, Path, Path]:
    lab_dir = root / "artifacts" / "lab"
    return (
        lab_dir / "heartbeat.json",
        lab_dir / "worker.pid",
        lab_dir / "worker_info.json",
    )


def _lab_worker_status(root: Path) -> Dict[str, Any]:
    heartbeat_path, pid_path, info_path = _lab_worker_paths(root)
    heartbeat = _read_json(heartbeat_path) if heartbeat_path.exists() else None
    info = _read_json(info_path) if info_path.exists() else None
    pid = None
    running = False
    if pid_path.exists():
        try:
            pid = int(pid_path.read_text(encoding="utf-8").strip())
            running = pid_running(pid)
        except Exception:
            running = False
    hb_ts = None
    hb_age = None
    if isinstance(heartbeat, dict):
        try:
            hb_ts = float(heartbeat.get("ts"))
        except Exception:
            hb_ts = None
    if hb_ts:
        hb_age = max(0.0, time.time() - hb_ts)
    try:
        stale_sec = float(os.getenv("AJAX_LAB_WORKER_STALE_SEC", "30") or 30)
    except Exception:
        stale_sec = 30.0
    status = "unknown"
    if isinstance(heartbeat, dict) and heartbeat.get("status"):
        status = str(heartbeat.get("status"))
    derived = status
    if not running:
        derived = "down"
    elif hb_age is not None and hb_age > stale_sec:
        derived = "stale"
    return {
        "status": status,
        "derived_status": derived,
        "heartbeat_age_s": hb_age,
        "last_heartbeat_ts": hb_ts,
        "pid": pid,
        "running": running,
        "heartbeat_path": str(heartbeat_path),
        "pid_path": str(pid_path),
        "worker_info_path": str(info_path),
        "worker_id": heartbeat.get("worker_id") if isinstance(heartbeat, dict) else None,
        "version": heartbeat.get("version") if isinstance(heartbeat, dict) else None,
        "capabilities": heartbeat.get("capabilities") if isinstance(heartbeat, dict) else None,
        "driver_url": heartbeat.get("driver_url") if isinstance(heartbeat, dict) else None,
        "info": info if isinstance(info, dict) else None,
    }


def _detect_repo_root(root_override: Optional[str] = None) -> Path:
    def _has_repo_markers(path: Path) -> bool:
        markers = [
            path / "AGENTS.md",
            path / "bin" / "ajaxctl",
            path / "agency",
        ]
        return all(marker.exists() for marker in markers)

    if root_override:
        candidate = Path(root_override).expanduser().resolve()
    else:
        candidate = ROOT

    kernel_candidate = candidate / "ajax-kernel"
    if _has_repo_markers(candidate):
        if candidate.name != "ajax-kernel" and _has_repo_markers(kernel_candidate):
            return kernel_candidate
        return candidate
    if _has_repo_markers(kernel_candidate):
        return kernel_candidate
    raise RuntimeError("repo_root no detectado; ejecuta desde AJAX_HOME o pasa --root")


def _whereami_env_value(key: str) -> str:
    value = os.environ.get(key)
    if value is None or value == "":
        return "(unset)"
    upper = key.upper()
    if "KEY" in upper or "TOKEN" in upper or "SECRET" in upper:
        return "<redacted>"
    return value


def cmd_do(args: argparse.Namespace) -> int:
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    intention = " ".join(args.intention).strip()
    if not intention:
        print("No intention provided.", file=sys.stderr)
        return 1
    res = core.do(intention)
    mission_id = getattr(res, "mission_id", None) or getattr(core, "_last_mission_id", None)
    payload = {
        "success": res.success,
        "mission_id": mission_id,
        "plan_id": res.plan_id,
        "path": res.path,
        "detail": res.detail,
        "artifacts": res.artifacts,
        "error": res.error,
    }
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0 if res.success else 2


def cmd_media_verify(args: argparse.Namespace) -> int:
    try:
        from agency.media_verify import run_media_verify
    except Exception as exc:
        print(f"media_verify_unavailable:{exc}", file=sys.stderr)
        return 3

    mission_id = str(getattr(args, "mission_id", None) or os.getenv("AJAX_MISSION_ID") or "mission").strip()
    if not mission_id:
        mission_id = "mission"

    res = run_media_verify(
        root_dir=ROOT,
        mission_id=mission_id,
        browser_process=str(getattr(args, "browser_process", None) or "brave.exe"),
        expected_artist=str(getattr(args, "expected_artist", None) or "Extremoduro"),
        expected_title_hint=str(getattr(args, "expected_title", None) or "Standby"),
        time_window_s=float(getattr(args, "time_window_s", 4.0) or 4.0),
        min_time_delta_s=float(getattr(args, "min_time_delta_s", 2.0) or 2.0),
        audio_motion_threshold=float(getattr(args, "audio_motion_threshold", 2.0) or 2.0),
    )

    # Receipt exec (minimal)
    try:
        ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
        receipt_dir = ROOT / "artifacts" / "receipts"
        receipt_dir.mkdir(parents=True, exist_ok=True)
        receipt_path = receipt_dir / f"exec_media_verify_{ts}.json"
        receipt_payload = {
            "schema_version": "0.1",
            "kind": "exec",
            "created_utc": ts,
            "what": "media_verify",
            "mission_id": mission_id,
            "artifacts": {
                "report": str(res.report_path),
                "dir": str(res.artifacts_dir),
            },
        }
        receipt_path.write_text(json.dumps(receipt_payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
    except Exception:
        receipt_path = None

    out = {
        "ok": bool(res.ok),
        "mission_id": mission_id,
        "report_path": str(res.report_path),
        "artifacts_dir": str(res.artifacts_dir),
        "receipt": str(receipt_path) if receipt_path else None,
    }
    print(json.dumps(out, ensure_ascii=False, indent=2))
    return 0 if res.ok else 2


def cmd_plan(args: argparse.Namespace) -> int:
    """
    Planning-only harness (no actuation).
    - Builds an empty observation by default (no driver dependency).
    - Emits the plan JSON to stdout so planning can be validated deterministically.
    """
    try:
        from dataclasses import asdict
        from agency.ajax_core import AjaxObservation, MissionState
    except Exception as exc:  # pragma: no cover - optional deps
        print(f"Imports fallidos: {exc}", file=sys.stderr)
        return 3
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3

    intention = " ".join(args.intention).strip()
    if not intention:
        print("No intention provided.", file=sys.stderr)
        return 1

    if getattr(args, "perceive", False):
        try:
            observation = core.perceive()
        except Exception as exc:
            print(f"perceive_failed: {exc}", file=sys.stderr)
            return 3
    else:
        observation = AjaxObservation(
            timestamp=time.time(), foreground=None, notes={"source": "cli_plan"}
        )

    mission = MissionState(intention=intention)
    brain_exclude = None
    if getattr(args, "exclude_provider", None):
        brain_exclude = {
            str(p).strip() for p in args.exclude_provider if isinstance(p, str) and p.strip()
        }
    try:
        plan = core.plan(intention, observation, mission=mission, brain_exclude=brain_exclude)
    except Exception as exc:
        payload = {"ok": False, "mission_id": mission.mission_id, "error": str(exc)}
        print(json.dumps(payload, indent=2, ensure_ascii=False))
        return 2

    payload = {"ok": bool(plan.steps), "mission_id": mission.mission_id, "plan": asdict(plan)}
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0 if plan.steps else 2


def cmd_subcall(args: argparse.Namespace) -> int:
    """
    DEV_DELEGATION: subcall unificado (policy+ledger) para sub-roles T0–T2.
    - Entrada: prompt por argv o stdin.
    - Salida: stdout (texto o JSON) + receipt durable en artifacts/receipts/.
    """
    try:
        from agency.subcall import run_subcall  # type: ignore
    except Exception as exc:  # pragma: no cover - optional deps
        print(f"subcall_unavailable:{exc}", file=sys.stderr)
        return 3

    prompt = " ".join(getattr(args, "prompt", []) or []).strip()
    use_stdin = bool(getattr(args, "stdin", False))
    try:
        if use_stdin or (not prompt and not sys.stdin.isatty()):
            prompt = sys.stdin.read()
    except Exception:
        pass

    try:
        if not os.getenv("AJAX_COST_MODE"):
            os.environ["AJAX_COST_MODE"] = _default_cost_mode(ROOT)
        result = run_subcall(
            root_dir=ROOT,
            role=str(args.role),
            tier=str(args.tier),
            prompt=str(prompt or ""),
            json_mode=bool(getattr(args, "json", False)),
            allow_premium_subcall=bool(getattr(args, "allow_premium_subcall", False)),
            read_ledger=not bool(getattr(args, "smoke_bypass_ledger", False)),
            force_provider=getattr(args, "smoke_force_provider", None),
        )
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2

    if result.output_text:
        sys.stdout.write(result.output_text)
    if not result.ok:
        msg = result.error or result.terminal or "subcall_failed"
        print(msg, file=sys.stderr)
    return 0 if result.ok else 2


def _get_capabilities_summary() -> Dict[str, Any]:
    diskann_enforced = (os.environ.get("AJAX_REQUIRE_DISKANN") or "").strip().lower() in {
        "1",
        "true",
        "yes",
        "on",
    }
    return {
        "openai": "enabled" if os.environ.get("OPENAI_API_KEY") else "disabled",
        "diskann_mode": "enforced" if diskann_enforced else "optional",
        "profile_heuristic": "test-full" if diskann_enforced else "test-fast/default",
    }


def cmd_health(args: argparse.Namespace) -> int:
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    report = core.health_check(strict=False)
    payload = report.to_dict() if hasattr(report, "to_dict") else report
    if isinstance(payload, dict) and not payload.get("driver_ok", True):
        payload["reason"] = "DRIVER_DEGRADED"
        payload["recommended_action"] = "wait_or_restart"
    if isinstance(payload, dict):
        payload["capabilities"] = _get_capabilities_summary()
    try:
        slots_health = core._check_slots_health() if hasattr(core, "_check_slots_health") else None  # type: ignore[attr-defined]
        if isinstance(payload, dict):
            payload["model_slots_health"] = slots_health
    except Exception:
        pass

    try:
        from agency.health_ttl import provider_status_ttl  # type: ignore

        try:
            ttl_seconds = int(os.getenv("AJAX_HEALTH_TTL_SEC") or 900)
        except Exception:
            ttl_seconds = 900
        freshness = provider_status_ttl(ROOT, ttl_seconds=ttl_seconds)
        if isinstance(payload, dict):
            payload["providers_status_ttl"] = freshness
            if freshness.get("stale"):
                payload["ok"] = False
                payload["stale_health"] = True
                payload["reason"] = "HEALTH_STALE"
                payload["recommended_action"] = "run_doctor_providers_or_refresh_status"
    except Exception:
        pass

    hunger_state = None
    try:
        from agency.hunger import get_current_hunger
        hunger_state = get_current_hunger(ROOT)
        if isinstance(payload, dict) and hunger_state:
            import dataclasses
            payload["hunger"] = dataclasses.asdict(hunger_state)
    except Exception:
        pass

    print(json.dumps(payload, indent=2, ensure_ascii=False))
    
    if hunger_state and not getattr(args, "json", False):
        s = hunger_state
        print(f"Hambre: {s.hunger:.2f} (amb {s.inputs.user_ambition:.2f}, cap {s.inputs.system_capacity:.2f}, nov {s.inputs.context_novelty:.2f}) -> explore {s.decision.explore_budget:.2f}, gaps@{s.decision.gap_threshold}, policy v{s.policy_version}")

    return 0 if payload.get("ok", False) else 3


def cmd_cloud_canary(args: argparse.Namespace) -> int:
    try:
        from agency.cloud_bench import run_cloud_canary  # type: ignore
    except Exception as exc:  # pragma: no cover
        print(f"cloud_canary_unavailable:{exc}", file=sys.stderr)
        return 3
    provider = str(args.provider or "").strip()
    if not provider:
        print("provider required (--provider)", file=sys.stderr)
        return 2
    model = str(args.model).strip() if getattr(args, "model", None) else None
    try:
        payload = run_cloud_canary(
            root_dir=ROOT, provider=provider, model=model, json_output=bool(args.json)
        )
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2
    if args.json:
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        ok = payload.get("success")
        msg = "OK" if ok else f"FAIL ({payload.get('error_kind')})"
        print(
            f"cloud-canary {provider}:{payload.get('model')}: {msg} total_ms={payload.get('total_ms')}"
        )
    return 0 if payload.get("success") else 2


def cmd_cloud_bench(args: argparse.Namespace) -> int:
    try:
        from agency.cloud_bench import run_cloud_bench  # type: ignore
    except Exception as exc:  # pragma: no cover
        print(f"cloud_bench_unavailable:{exc}", file=sys.stderr)
        return 3
    suite = str(args.suite or "crawl_v1").strip()
    providers = (
        [p.strip() for p in (args.providers or []) if p.strip()]
        if getattr(args, "providers", None)
        else None
    )
    runs = int(getattr(args, "runs", 3) or 3)
    budget = str(getattr(args, "budget", "tiny") or "tiny")
    allow_premium = bool(getattr(args, "allow_premium_subcall", False))
    confirm = str(getattr(args, "confirm_premium", "") or "").strip().lower()
    if confirm == "confirmo premium":
        allow_premium = True
    try:
        report = run_cloud_bench(
            root_dir=ROOT,
            suite=suite,
            providers=providers,
            runs=runs,
            budget=budget,
            allow_premium=allow_premium,
        )
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2
    if args.json:
        print(json.dumps(report, ensure_ascii=False, indent=2))
    else:
        paths = report.get("paths") if isinstance(report, dict) else None
        print(f"cloud-bench done: suite={suite} runs={runs} budget={budget}")
        if isinstance(paths, dict):
            print(f"- json: {paths.get('json')}")
            print(f"- md: {paths.get('md')}")
            print(f"- latest: {paths.get('latest')}")
            print(f"- scoreboard: {paths.get('scoreboard')}")
    return 0


def cmd_lmstudio_bench(args: argparse.Namespace) -> int:
    try:
        from agency.lmstudio_bench import run_lmstudio_bench  # type: ignore
    except Exception as exc:  # pragma: no cover
        print(f"lmstudio_bench_unavailable:{exc}", file=sys.stderr)
        return 3
    suite = str(args.suite or "crawl_v1").strip()
    models_filter = str(getattr(args, "models", "all") or "all").strip()
    runs = int(getattr(args, "runs", 3) or 3)
    select_best = bool(getattr(args, "select_best", False))
    try:
        report = run_lmstudio_bench(
            root_dir=ROOT,
            suite=suite,
            models_filter=models_filter,
            runs=runs,
            select_best=select_best,
        )
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2
    if args.json:
        print(json.dumps(report, ensure_ascii=False, indent=2))
    else:
        paths = report.get("paths") if isinstance(report, dict) else None
        print(f"lmstudio-bench done: suite={suite} runs={runs}")
        if isinstance(paths, dict):
            print(f"- json: {paths.get('json')}")
            print(f"- md: {paths.get('md')}")
            print(f"- latest: {paths.get('latest')}")
            if paths.get("fallback"):
                print(f"- fallback: {paths.get('fallback')}")
    return 0


def cmd_lmstudio_test(args: argparse.Namespace) -> int:
    try:
        from agency.lmstudio_bench import run_lmstudio_test  # type: ignore
    except Exception as exc:  # pragma: no cover
        print(f"lmstudio_test_unavailable:{exc}", file=sys.stderr)
        return 3
    try:
        payload = run_lmstudio_test(root_dir=ROOT)
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2
    if args.json:
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        ok = payload.get("success")
        msg = "OK" if ok else f"FAIL ({payload.get('error_kind')})"
        print(f"lmstudio-test {payload.get('model')}: {msg} total_ms={payload.get('total_ms')}")
    return 0 if payload.get("success") else 2


def cmd_ledger(args: argparse.Namespace) -> int:
    try:
        from agency.provider_ledger import ProviderLedger
    except Exception as exc:
        print(f"Ledger no disponible: {exc}", file=sys.stderr)
        return 3

    ledger = ProviderLedger(root_dir=ROOT)
    doc = None
    if getattr(args, "no_refresh", False):
        doc = ledger.load_latest()
        if not doc:
            doc = ledger.refresh()
    else:
        doc = ledger.refresh()

    rows = doc.get("rows") if isinstance(doc, dict) else None
    rows = rows if isinstance(rows, list) else []

    if getattr(args, "json", False):
        print(json.dumps(doc, ensure_ascii=False, indent=2))
        return 0

    # Default: table
    print(
        "provider\tmodel\trole\tstatus\treason\tcooldown_until\tlast_ok_ts\tlast_fail_ts\tcost_class"
    )
    for row in rows:
        if not isinstance(row, dict):
            continue
        print(
            "\t".join(
                [
                    str(row.get("provider") or ""),
                    str(row.get("model") or ""),
                    str(row.get("role") or ""),
                    str(row.get("status") or ""),
                    str(row.get("reason") or ""),
                    str(row.get("cooldown_until") or ""),
                    str(row.get("last_ok_ts") or ""),
                    str(row.get("last_fail_ts") or ""),
                    str(row.get("cost_class") or ""),
                ]
            )
        )
    return 0


def _load_provider_configs() -> Dict[str, Any]:
    cfg_yaml_path = ROOT / "config" / "model_providers.yaml"
    cfg_json_path = ROOT / "config" / "model_providers.json"
    data: Any = None

    if cfg_yaml_path.exists():
        try:
            import yaml  # type: ignore
        except Exception:
            yaml = None  # type: ignore
        if yaml is not None:
            try:
                data = yaml.safe_load(cfg_yaml_path.read_text(encoding="utf-8")) or {}
            except Exception:
                data = None

    if data is None and cfg_json_path.exists():
        try:
            data = json.loads(cfg_json_path.read_text(encoding="utf-8"))
        except Exception:
            data = {}

    return data.get("providers", {}) if isinstance(data, dict) else {}


def _load_provider_policy() -> Dict[str, Any]:
    try:
        from agency.policy_contract import validate_policy_contract  # type: ignore
    except Exception:
        validate_policy_contract = None  # type: ignore
    if validate_policy_contract is not None:
        try:
            validate_policy_contract(ROOT, sync_json=True, write_receipt=False)
        except Exception:
            pass
    try:
        from agency.provider_policy import load_provider_policy  # type: ignore
    except Exception:
        return {}
    try:
        data = load_provider_policy(ROOT)
    except Exception:
        data = {}
    return data if isinstance(data, dict) else {}


def _capabilities_for_cfg(cfg: Dict[str, Any]) -> Dict[str, bool]:
    roles = cfg.get("roles") or []
    if isinstance(roles, str):
        roles = [roles]
    roles_l = {str(r).strip().lower() for r in roles if r}
    kind = str(cfg.get("kind") or "").strip().lower()
    base_url = cfg.get("base_url")
    is_local = bool(kind == "static")
    if isinstance(base_url, str):
        url = base_url.strip().lower()
        if "localhost" in url or "127.0.0.1" in url:
            is_local = True
    return {
        "text_local": bool(is_local and roles_l.intersection({"brain", "council", "scout"})),
        "vision_local": bool(is_local and "vision" in roles_l),
    }


def _policy_state(policy_doc: Dict[str, Any], provider: str, cap: str) -> Optional[str]:
    providers = policy_doc.get("providers") if isinstance(policy_doc, dict) else None
    if not isinstance(providers, dict):
        return None
    ent = providers.get(provider)
    if not isinstance(ent, dict):
        return None
    key = f"policy_state_{cap}"
    state = ent.get(key)
    if not state:
        state = ent.get("policy_state")
    if isinstance(state, str) and state.strip():
        return state.strip().lower()
    return None


def _last_provider_error(entry: Dict[str, Any]) -> Optional[str]:
    events = entry.get("events")
    if isinstance(events, list) and events:
        for ev in reversed(events):
            if not isinstance(ev, dict):
                continue
            if ev.get("ok") is False:
                err = str(ev.get("error") or ev.get("outcome") or "").strip()
                if err:
                    return err
    breathing = entry.get("breathing")
    if isinstance(breathing, dict):
        reason = str(breathing.get("reason") or "").strip()
        if reason:
            return reason
    return None


def cmd_providers_status(args: argparse.Namespace) -> int:
    providers_cfg = _load_provider_configs()
    provider_configs = {"providers": providers_cfg}
    policy_doc = _load_provider_policy()
    now = time.time()

    try:
        from agency.provider_breathing import ProviderBreathingLoop  # type: ignore
    except Exception as exc:
        ProviderBreathingLoop = None  # type: ignore
        print(f"provider_breathing_no_disponible: {exc}", file=sys.stderr)
    try:
        from agency.provider_ledger import ProviderLedger  # type: ignore
    except Exception as exc:
        ProviderLedger = None  # type: ignore
        print(f"provider_ledger_no_disponible: {exc}", file=sys.stderr)

    breathing_doc = None
    if ProviderBreathingLoop is not None and not getattr(args, "no_refresh", False):
        try:
            loop = ProviderBreathingLoop(root_dir=ROOT, provider_configs=provider_configs)
            breathing_doc = loop.run_once(roles=["brain", "council", "scout", "vision"])
        except Exception as exc:
            print(f"provider_breathing_failed: {exc}", file=sys.stderr)

    ledger_doc: Dict[str, Any] = {}
    if ProviderLedger is not None:
        try:
            ledger = ProviderLedger(root_dir=ROOT, provider_configs=provider_configs)
            if getattr(args, "no_refresh", False):
                ledger_doc = ledger.load_latest() or {}
                if not ledger_doc:
                    ledger_doc = ledger.refresh()
            else:
                ledger_doc = ledger.refresh()
        except Exception as exc:
            print(f"provider_ledger_failed: {exc}", file=sys.stderr)
            ledger_doc = {}

    status_path = ROOT / "artifacts" / "health" / "providers_status.json"
    status_doc = _read_json(status_path) if status_path.exists() else None
    if not isinstance(status_doc, dict):
        status_doc = {}

    providers_status = status_doc.get("providers") if isinstance(status_doc, dict) else {}
    if not isinstance(providers_status, dict):
        providers_status = {}

    ledger_rows = ledger_doc.get("rows") if isinstance(ledger_doc, dict) else None
    ledger_rows = ledger_rows if isinstance(ledger_rows, list) else []
    if not ledger_rows and providers_status:
        rebuilt_rows: list[dict] = []
        for name, entry in providers_status.items():
            if not isinstance(entry, dict):
                continue
            breathing = entry.get("breathing") if isinstance(entry.get("breathing"), dict) else {}
            roles = breathing.get("roles") if isinstance(breathing.get("roles"), dict) else {}
            role_keys = [str(r).strip().lower() for r in roles.keys() if str(r).strip()]
            if not role_keys:
                role_keys = ["brain"]
            unavailable = entry.get("unavailable_reason")
            available_recent = bool(entry.get("available_recent"))
            status = (
                "ok" if available_recent and not unavailable else str(unavailable or "unavailable")
            )
            reason = None if status == "ok" else str(unavailable or "unavailable")
            for role in role_keys:
                rebuilt_rows.append(
                    {
                        "provider": str(name),
                        "model": None,
                        "role": role,
                        "status": status,
                        "reason": reason,
                        "available_recent": available_recent,
                        "latency_p95_ms": entry.get("latency_p95_ms"),
                        "timeout_rate_recent": entry.get("timeout_rate_recent"),
                        "failure_rate_recent": entry.get("failure_rate_recent"),
                        "details": {"source": "providers_status"},
                    }
                )
        ledger_doc = {
            "schema": "ajax.provider_ledger.v1",
            "updated_ts": now,
            "updated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(now)),
            "path": str(ROOT / "artifacts" / "provider_ledger" / "latest.json"),
            "rows": rebuilt_rows,
        }
        try:
            ledger_path = ROOT / "artifacts" / "provider_ledger" / "latest.json"
            ledger_path.parent.mkdir(parents=True, exist_ok=True)
            ledger_path.write_text(
                json.dumps(ledger_doc, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
            )
        except Exception:
            pass
        ledger_rows = rebuilt_rows

    ledger_by_provider: Dict[str, List[Dict[str, Any]]] = {}
    for row in ledger_rows:
        if not isinstance(row, dict):
            continue
        prov = str(row.get("provider") or "").strip()
        if not prov:
            continue
        ledger_by_provider.setdefault(prov, []).append(row)

    provider_names = (
        sorted(providers_cfg.keys()) if providers_cfg else sorted(providers_status.keys())
    )

    summary: Dict[str, Any] = {}
    for name in provider_names:
        cfg = providers_cfg.get(name) or {}
        if not isinstance(cfg, dict):
            continue
        kind = str(cfg.get("kind") or "").strip().lower()
        entry = providers_status.get(name) if isinstance(providers_status, dict) else None
        entry = entry if isinstance(entry, dict) else {}
        detected = (
            bool(entry)
            if not providers_cfg
            else bool(not cfg.get("disabled") and kind and kind != "static")
        )
        auth_state = str(entry.get("auth_state") or "").strip().upper()
        requires_auth = bool(cfg.get("requires_auth", False))
        if requires_auth:
            auth_ok = auth_state == "OK"
        else:
            auth_ok = auth_state not in {"MISSING", "EXPIRED"}

        ledger_rows_p = ledger_by_provider.get(name, [])
        health_ok: Optional[bool] = None
        if ledger_rows_p:
            health_ok = all(str(row.get("status") or "") == "ok" for row in ledger_rows_p)
        else:
            breathing = entry.get("breathing") if isinstance(entry, dict) else None
            if isinstance(breathing, dict):
                status = str(breathing.get("status") or "").upper()
                if status in {"UP", "DEGRADED"}:
                    health_ok = True
                elif status == "DOWN":
                    health_ok = False

        quota_state = "ok"
        cooldown_until = None
        cooldown_until_ts = None
        for row in ledger_rows_p:
            if str(row.get("reason") or "") in {"quota_exhausted", "429_tpm"}:
                cooldown_until = row.get("cooldown_until")
                cooldown_until_ts = row.get("cooldown_until_ts")
                if isinstance(cooldown_until_ts, (int, float)) and cooldown_until_ts > now:
                    quota_state = "cooldown"
                else:
                    quota_state = "quota_exhausted"
                break

        last_error = _last_provider_error(entry)
        p95_ms = entry.get("latency_p95_ms") if isinstance(entry, dict) else None
        capabilities = _capabilities_for_cfg(cfg)
        policy_state = {
            "text": _policy_state(policy_doc, name, "text"),
            "vision": _policy_state(policy_doc, name, "vision"),
        }

        summary[name] = {
            "detected": detected,
            "auth_ok": bool(auth_ok),
            "health_ok": health_ok,
            "quota_state": quota_state,
            "last_error": last_error,
            "p95_ms": p95_ms,
            "cooldown_until": cooldown_until,
            "cooldown_until_ts": cooldown_until_ts,
            "capabilities": capabilities,
            "policy_state": policy_state,
        }

    payload = {
        "ok": True,
        "updated_ts": now,
        "updated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(now)),
        "providers_status_path": str(status_path),
        "provider_ledger_path": ledger_doc.get("path")
        if isinstance(ledger_doc, dict)
        else str(ROOT / "artifacts" / "provider_ledger" / "latest.json"),
        "providers": summary,
    }
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
        return 0
    print("provider\tdetected\tauth_ok\thealth_ok\tquota_state\tp95_ms\tlast_error")
    for name, info in summary.items():
        print(
            "\t".join(
                [
                    str(name),
                    str(info.get("detected")),
                    str(info.get("auth_ok")),
                    str(info.get("health_ok")),
                    str(info.get("quota_state")),
                    str(info.get("p95_ms") or ""),
                    str(info.get("last_error") or ""),
                ]
            )
        )
    return 0


def cmd_provider_ping(args: argparse.Namespace) -> int:
    try:
        from agency.provider_health import run_provider_ping  # type: ignore
    except Exception as exc:  # pragma: no cover
        print(f"provider_ping_unavailable:{exc}", file=sys.stderr)
        return 3
    provider = str(args.provider or "").strip()
    if not provider:
        print("provider required (--provider)", file=sys.stderr)
        return 2
    model = str(args.model).strip() if getattr(args, "model", None) else None
    timeout_ttft = getattr(args, "timeout_ttft", None)
    timeout_total = getattr(args, "timeout_total", None)
    timeout_stall = getattr(args, "timeout_stall", None)
    try:
        out_path, payload = run_provider_ping(
            ROOT,
            provider=provider,
            model=model,
            timeout_ttft_ms=int(timeout_ttft) if timeout_ttft is not None else None,
            timeout_total_ms=int(timeout_total) if timeout_total is not None else None,
            timeout_stall_ms=int(timeout_stall) if timeout_stall is not None else None,
        )
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 2
    receipt = {
        "schema": "ajax.provider_ping_receipt.v1",
        "provider": provider,
        "model": payload.get("model"),
        "ok": bool(payload.get("ok")),
        "outcome": payload.get("outcome"),
        "ttft_ms": payload.get("ttft_ms"),
        "total_ms": payload.get("total_ms"),
        "timeout_kind": payload.get("timeout_kind"),
        "path": str(out_path),
        "ts": payload.get("ts"),
        "ts_utc": payload.get("ts_utc"),
    }
    receipt_path = None
    try:
        receipts_dir = ROOT / "artifacts" / "receipts"
        receipts_dir.mkdir(parents=True, exist_ok=True)
        ts_label = str(payload.get("ts") or int(time.time()))
        receipt_path = receipts_dir / f"provider_ping_{ts_label}.json"
        receipt_path.write_text(
            json.dumps(receipt, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
        )
    except Exception:
        receipt_path = None
    if args.json:
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        msg = "OK" if payload.get("ok") else f"FAIL ({payload.get('outcome')})"
        print(
            f"provider-ping {provider}:{payload.get('model')}: {msg} ttft_ms={payload.get('ttft_ms')} total_ms={payload.get('total_ms')}"
        )
        if receipt_path:
            print(f"receipt={receipt_path}")
    return 0 if payload.get("ok") else 2


def cmd_agent(args: argparse.Namespace) -> int:
    if run_agentic_session is None or AgentConstraints is None:
        print("PAS no disponible (imports fallaron).", file=sys.stderr)
        return 3
    goal = " ".join(args.goal).strip()
    if not goal:
        print("Debes indicar un goal (agent_goal).", file=sys.stderr)
        return 1
    constraints = AgentConstraints(
        max_missions=args.max_missions,
        max_runtime_sec=args.max_runtime,
        max_consecutive_failures=args.max_failures,
    )
    res = run_agentic_session(goal, constraints=constraints)
    print(json.dumps(res.to_dict(), ensure_ascii=False, indent=2))
    if getattr(args, "voice", False) and Voice is not None:
        try:
            voice = Voice()
            voice.speak(res.final_state_summary)
        except Exception:
            pass
    return 0 if res.status == "success" else 2


def _shorten(val: Any, max_len: int = 240) -> str:
    try:
        text = json.dumps(val, ensure_ascii=False)
    except Exception:
        text = str(val)
    if len(text) > max_len:
        return text[:max_len] + "…"
    return text


def _ux_profile() -> str:
    profile = (os.getenv("AJAX_UX_PROFILE") or "debug").strip().lower()
    return "user" if profile == "user" else "debug"


def _env_truthy(name: str, default: Optional[bool] = None) -> bool:
    raw = os.getenv(name)
    if raw is None:
        return bool(default) if default is not None else False
    val = str(raw).strip().lower()
    if not val:
        return bool(default) if default is not None else False
    return val in {"1", "true", "yes", "on"}


def _fmt_age(seconds: Optional[float]) -> str:
    if seconds is None:
        return "unknown"
    try:
        sec = max(0, int(seconds))
    except Exception:
        return "unknown"
    if sec < 60:
        return f"{sec}s"
    if sec < 3600:
        return f"{sec // 60}m{sec % 60:02d}s"
    hours = sec // 3600
    minutes = (sec % 3600) // 60
    return f"{hours}h{minutes:02d}m"


def _fmt_ts(timestamp: Optional[float]) -> str:
    if timestamp is None:
        return "unknown"
    try:
        return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(float(timestamp)))
    except Exception:
        return "unknown"


def _parse_priority_value(value: Optional[str]) -> int:
    if value is None:
        return 50
    label = str(value).strip().lower()
    if label in {"high", "h"}:
        return 90
    if label in {"med", "medium", "m"}:
        return 50
    if label in {"low", "l"}:
        return 30
    try:
        return max(0, min(int(label), 100))
    except Exception:
        return 50


def _lab_status_lines(root_dir: Path, job_id: str) -> tuple[Optional[dict], list[str]]:
    try:
        store = LabStateStore(root_dir)
        job, job_path = store.load_job(str(job_id))
        info = store.annotate_job_staleness(job, job_path)
    except Exception:
        return None, []
    last_heartbeat = _fmt_ts(job.get("last_heartbeat_ts") if isinstance(job, dict) else None)
    lines = [
        f"LAB: status={info.get('status')} job_age={_fmt_age(info.get('job_age_s'))} "
        f"heartbeat_age={_fmt_age(info.get('heartbeat_age_s'))} last_heartbeat={last_heartbeat}",
    ]
    try:
        qpos = store.queue_position(str(job_id))
        if qpos and str(job.get("status") or "").upper() == "QUEUED":
            lines.append(f"LAB: queue_position≈{qpos.get('position')}/{qpos.get('depth')}")
    except Exception:
        pass
    if info.get("is_stale"):
        reason = info.get("reason") or "unknown"
        lines.append(f"LAB: STALE (reason={reason})")
        lines.append("Opciones: [cancel_job] [requeue_job] [open_incident]")
        if info.get("fail_closed"):
            lines.append("LAB: FAIL-CLOSED by stale policy (NoUserLeftBehind).")
    fail_summary = job.get("failure_summary") if isinstance(job, dict) else None
    if isinstance(fail_summary, str) and fail_summary.strip():
        lines.append(f"LAB: failure_summary={_shorten(fail_summary, max_len=200)}")
    try:
        output_paths = job.get("output_paths") or []
        if isinstance(output_paths, list) and output_paths:
            rel_paths = []
            for path in output_paths:
                if not path:
                    continue
                try:
                    rel_paths.append(os.path.relpath(path, root_dir) if root_dir else str(path))
                except Exception:
                    rel_paths.append(str(path))
            if rel_paths:
                lines.append(f"Refs (outputs): {', '.join(rel_paths[:4])}")
    except Exception:
        pass
    try:
        rel_job = os.path.relpath(job_path, root_dir) if root_dir else str(job_path)
        lines.append(f"Refs (job): {rel_job}")
    except Exception:
        pass
    return info, lines


def _resolve_waiting_context(root_dir: Path) -> tuple[Optional[dict], Optional[str], Optional[str]]:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        return None, None, None
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    mission_id = payload.get("mission_id") or mission_raw.get("mission_id")
    job_id = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    return payload, mission_id, job_id


def _waiting_lab_job_id(root_dir: Path) -> Optional[str]:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        return None
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    job_id = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    return str(job_id) if job_id else None


def _describe_snapshot_with_vision(image_path: str) -> Optional[str]:
    try:
        from agency.vision_llm import call_vision_llm
    except Exception:
        return None
    backend = (os.getenv("AJAX_SNAP_VISION_BACKEND") or "local").strip().lower()
    prompt = "Describe the screenshot briefly for observability."
    ttft_ms = int(os.getenv("AJAX_VISION_TTFT_TIMEOUT_MS") or "120000")
    total_ms = int(os.getenv("AJAX_VISION_TOTAL_TIMEOUT_MS") or "180000")
    t0 = time.monotonic()
    try:
        resp = call_vision_llm(
            image_path=image_path,
            user_prompt=prompt,
            backend=backend,
            timeout_s=max(1, int(total_ms / 1000)),
        )
    except Exception as exc:
        elapsed_ms = int((time.monotonic() - t0) * 1000)
        err_txt = str(exc)
        kind = "UNKNOWN"
        if "connection" in err_txt.lower() or "refused" in err_txt.lower():
            kind = "CONN"
        elif "timeout" in err_txt.lower():
            kind = "TTFT" if elapsed_ms <= ttft_ms else "TOTAL"
        return f"vision_error:{kind}:{err_txt[:160]}"
    if not isinstance(resp, dict):
        return None
    text = resp.get("text") or resp.get("response") or resp.get("summary")
    return _shorten(text or "", max_len=360) if text else None


def _resolve_snap_rail(payload: Optional[dict], override: Optional[str] = None) -> str:
    if override:
        raw = str(override).strip().lower()
        if raw in {"prod", "production"}:
            return "prod"
        if raw in {"lab", "laboratory"}:
            return "lab"
    if payload:
        mission = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
        if mission.get("lab_job_id"):
            return "lab"
    env = (os.getenv("AJAX_RAIL") or os.getenv("AJAX_ENV") or os.getenv("AJAX_MODE") or "").strip()
    if env:
        val = env.lower()
        if val in {"prod", "production"}:
            return "prod"
        if val in {"lab", "laboratory"}:
            return "lab"
    return "prod"


def _safe_list_local_displays() -> Optional[list]:
    if not list_local_displays:
        return None
    try:
        payload = list_local_displays()
    except Exception:
        return None
    if not isinstance(payload, dict):
        return None
    displays = payload.get("displays")
    if isinstance(displays, list):
        return displays
    return None


def _format_display_selection(meta: dict, rail: str) -> Optional[str]:
    selected_id = meta.get("selected_display_id")
    display = meta.get("display") or {}
    bounds = display.get("bounds") if isinstance(display, dict) else None
    label = meta.get("selected_display_label") or "display"
    selected_by = meta.get("selected_by") or "heuristic"
    if selected_id is None and not display:
        return None
    parts = [f"display={rail}:{label}:{selected_id}" if selected_id is not None else f"display={rail}:{label}"]
    if isinstance(bounds, dict):
        try:
            parts.append(
                f"{bounds.get('width')}x{bounds.get('height')} @ x={bounds.get('x')},y={bounds.get('y')}"
            )
        except Exception:
            pass
    parts.append(f"by={selected_by}")
    return " ".join(parts)


def _handle_snap_request(
    root_dir: Path,
    *,
    mode: str,
    active_window: bool = False,
    attach_to: Optional[str] = None,
    mission_id: Optional[str] = None,
    job_id: Optional[str] = None,
    display_override: Optional[str] = None,
    rail: Optional[str] = None,
) -> Optional[dict]:
    if capture_desktop_snapshot is None:
        print("Snap no disponible (desktop_snap no importable).")
        return None
    payload = None
    waiting_status = None
    if attach_to or (mission_id is None and job_id is None):
        payload, wait_mission_id, wait_job_id = _resolve_waiting_context(root_dir)
        if mission_id is None:
            mission_id = wait_mission_id
        if job_id is None:
            job_id = wait_job_id
    if payload:
        waiting_status = str(payload.get("status") or "").upper()
    if attach_to == "mission" and not mission_id:
        print("No hay mision en espera para adjuntar snap.")
        return None
    if attach_to == "job" and not job_id:
        print("No hay job en espera para adjuntar snap.")
        return None
    if waiting_status and waiting_status not in {"WAITING_FOR_USER", "PAUSED_FOR_LAB"}:
        print(f"Snap solo disponible en WAITING_FOR_USER/PAUSED_FOR_LAB (status={waiting_status}).")
        return None
    ctx = mission_id or job_id or "manual"
    selection = None
    rail_resolved = _resolve_snap_rail(payload, rail)
    if resolve_display_selection and load_display_map:
        display_map = load_display_map(root_dir)
        selection = resolve_display_selection(
            rail=rail_resolved,
            displays=_safe_list_local_displays(),
            override=display_override,
            display_map=display_map,
        )
    result = capture_desktop_snapshot(
        root_dir=root_dir,
        active_window=bool(active_window),
        mission_id=mission_id,
        job_id=job_id,
        context=ctx,
        display_id=selection.get("display_id") if isinstance(selection, dict) else None,
        selection=selection if isinstance(selection, dict) else None,
    )
    png_path = result.get("png_path")
    json_path = result.get("json_path")
    if png_path:
        try:
            rel = os.path.relpath(png_path, root_dir) if root_dir else str(png_path)
        except Exception:
            rel = str(png_path)
        print(f"📷 Snap guardado: {rel}")
    if json_path:
        try:
            rel = os.path.relpath(json_path, root_dir) if root_dir else str(json_path)
        except Exception:
            rel = str(json_path)
        print(f"Meta: {rel}")
    meta = result.get("meta") if isinstance(result, dict) else None
    if isinstance(meta, dict):
        summary = _format_display_selection(meta, rail_resolved)
        if summary:
            print(f"📷 {summary}")
        warnings = meta.get("display_warnings") or []
        if isinstance(warnings, list) and warnings:
            warn_txt = ", ".join(str(w) for w in warnings if w)
            if warn_txt:
                print(f"⚠️ display warnings: {warn_txt}")
                if "display_id_not_found" in warn_txt or "display_list_unavailable" in warn_txt:
                    print("Tip: ejecuta `ajaxctl display calibrate` para fijar dummy/primary.")
    if mode == "snap+vision" and png_path:
        vision_summary = _describe_snapshot_with_vision(str(png_path))
        if vision_summary:
            if vision_summary.startswith("vision_error:"):
                kind = vision_summary.split(":", 2)[1] if ":" in vision_summary else "UNKNOWN"
                receipt_path = _write_vision_error_receipt(
                    root_dir,
                    {
                        "schema": "ajax.vision_error.v1",
                        "ts": time.time(),
                        "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                        "vision_error_kind": kind,
                        "image_path": str(png_path),
                        "detail": vision_summary,
                    },
                )
                if receipt_path:
                    try:
                        rel = (
                            os.path.relpath(receipt_path, root_dir)
                            if root_dir
                            else str(receipt_path)
                        )
                    except Exception:
                        rel = str(receipt_path)
                    print(f"VISION: error={kind} receipt={rel}")
                else:
                    print(f"VISION: error={kind}")
                print("Describe lo que ves para continuar (texto libre).")
            else:
                print(f"VISION: {vision_summary}")
    return result


def _resolve_lab_driver_url() -> str:
    env_url = (os.getenv("OS_DRIVER_URL_LAB") or "").strip()
    if env_url:
        return env_url.rstrip("/")
    env_host = (os.getenv("OS_DRIVER_HOST_LAB") or "").strip()
    env_port = (os.getenv("OS_DRIVER_PORT_LAB") or "").strip() or "5012"
    if env_host:
        return f"http://{env_host}:{env_port}"
    return f"http://127.0.0.1:{env_port}"


def _resolve_prod_driver_url() -> str:
    env_url = (os.getenv("OS_DRIVER_URL") or "").strip()
    if env_url:
        return env_url.rstrip("/")
    env_host = (os.getenv("OS_DRIVER_HOST") or "").strip()
    env_port = (os.getenv("OS_DRIVER_PORT") or "").strip() or "5010"
    if env_host:
        return f"http://{env_host}:{env_port}"
    return f"http://127.0.0.1:{env_port}"


def _resolve_driver_url_for_rail(rail: str, override: Optional[str] = None) -> str:
    if override:
        return str(override).rstrip("/")
    if rail == "lab":
        return _resolve_lab_driver_url()
    return _resolve_prod_driver_url()


def _display_primary_id(displays: list[dict]) -> Optional[int]:
    for disp in displays:
        if disp.get("is_primary"):
            try:
                return int(disp.get("id"))
            except Exception:
                continue
    for disp in displays:
        try:
            return int(disp.get("id"))
        except Exception:
            continue
    return None


def _compute_image_variance(path: Path) -> Optional[float]:
    try:
        from PIL import Image, ImageStat
    except Exception:
        return None
    try:
        with Image.open(path) as img:
            stat = ImageStat.Stat(img)
            if not stat.var:
                return None
            return float(sum(stat.var) / max(1, len(stat.var)))
    except Exception:
        return None


def cmd_display_list(args: argparse.Namespace) -> int:
    if fetch_driver_displays is None:
        print("Display list no disponible (driver client no importable).", file=sys.stderr)
        return 3
    rail = _resolve_snap_rail(None, getattr(args, "rail", None))
    driver_url = _resolve_driver_url_for_rail(rail, getattr(args, "driver_url", None))
    try:
        payload = fetch_driver_displays(driver_url)
    except Exception as exc:
        print(f"Display list falló: {exc} (driver={driver_url})", file=sys.stderr)
        return 2
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
        return 0
    displays = payload.get("displays") if isinstance(payload, dict) else None
    if not isinstance(displays, list):
        print("No se encontraron displays.")
        return 0
    print(f"Displays ({len(displays)}):")
    for disp in displays:
        bounds = disp.get("bounds") if isinstance(disp, dict) else {}
        print(
            f"- id={disp.get('id')} primary={disp.get('is_primary')} bounds="
            f"{bounds.get('width')}x{bounds.get('height')} @ x={bounds.get('x')},y={bounds.get('y')}"
        )
    return 0


def cmd_display_calibrate(args: argparse.Namespace) -> int:
    if fetch_driver_displays is None or save_display_map is None:
        print("Display calibrate no disponible (imports incompletos).", file=sys.stderr)
        return 3
    rail = _resolve_snap_rail(None, getattr(args, "rail", None))
    driver_url = _resolve_driver_url_for_rail(rail, getattr(args, "driver_url", None))
    try:
        payload = fetch_driver_displays(driver_url)
    except Exception as exc:
        print(f"Display list falló: {exc} (driver={driver_url})", file=sys.stderr)
        return 2
    displays = payload.get("displays") if isinstance(payload, dict) else None
    if not isinstance(displays, list) or not displays:
        print("No se encontraron displays para calibrar.")
        return 2
    dummy_id = getattr(args, "dummy_id", None)
    prod_id = getattr(args, "prod_id", None)
    if dummy_id is None:
        print("Displays disponibles:")
        for disp in displays:
            bounds = disp.get("bounds") if isinstance(disp, dict) else {}
            print(
                f"- id={disp.get('id')} primary={disp.get('is_primary')} bounds="
                f"{bounds.get('width')}x{bounds.get('height')} @ x={bounds.get('x')},y={bounds.get('y')}"
            )
        choice = input("Selecciona el ID del dummy (LAB): ").strip()
        if not choice:
            print("Calibración cancelada.")
            return 2
        dummy_id = choice
    try:
        dummy_id_int = int(dummy_id)
    except Exception:
        print("dummy_id inválido.", file=sys.stderr)
        return 2
    if prod_id is None:
        prod_id = _display_primary_id(displays)
    try:
        prod_id_int = int(prod_id) if prod_id is not None else None
    except Exception:
        prod_id_int = None
    targets = {"lab": dummy_id_int}
    if prod_id_int is not None:
        targets["prod"] = prod_id_int
    path = save_display_map(ROOT, targets, source="calibrate")
    payload = {"ok": True, "display_targets": targets, "path": str(path)}
    print(json.dumps(payload, ensure_ascii=False, indent=2))
    return 0


def cmd_display_diag(args: argparse.Namespace) -> int:
    if fetch_driver_displays is None or load_ajax_driver_api_key is None:
        print("Display diag no disponible (imports incompletos).", file=sys.stderr)
        return 3
    rail = _resolve_snap_rail(None, getattr(args, "rail", None))
    driver_url = _resolve_driver_url_for_rail(rail, getattr(args, "driver_url", None))
    try:
        payload = fetch_driver_displays(driver_url)
    except Exception as exc:
        print(f"Display list falló: {exc} (driver={driver_url})", file=sys.stderr)
        return 2
    displays = payload.get("displays") if isinstance(payload, dict) else None
    if not isinstance(displays, list) or not displays:
        print("No se encontraron displays para diag.")
        return 2
    api_key = load_ajax_driver_api_key()
    headers = {"X-AJAX-KEY": api_key} if api_key else {}
    results: list[dict] = []
    for disp in displays:
        disp_id = disp.get("id")
        entry: Dict[str, Any] = {"display_id": disp_id, "display": disp, "ok": False}
        try:
            resp = requests.get(
                driver_url.rstrip("/") + "/screenshot",
                headers=headers,
                params={"display_id": disp_id},
                timeout=float(getattr(args, "timeout", None) or 15),
            )
            if resp.status_code >= 400:
                entry["error"] = f"driver_http_{resp.status_code}"
                results.append(entry)
                continue
            data = resp.json()
            if not data.get("ok"):
                entry["error"] = data.get("error")
                results.append(entry)
                continue
            path_raw = data.get("path") or ""
            entry["driver_path"] = path_raw
            if _normalize_driver_path is not None:
                path_raw = _normalize_driver_path(str(path_raw))
            snap_path = Path(str(path_raw))
            entry["local_path"] = str(snap_path)
            if snap_path.exists():
                variance = _compute_image_variance(snap_path)
                entry["variance"] = variance
                if variance is not None:
                    entry["black"] = variance < float(getattr(args, "black_threshold", None) or 5.0)
            entry["ok"] = True
        except Exception as exc:
            entry["error"] = str(exc)
        results.append(entry)
    out_dir = ROOT / "artifacts" / "observability" / "display"
    out_dir.mkdir(parents=True, exist_ok=True)
    ts = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())
    out_path = out_dir / f"diag_{ts}.json"
    receipt = {
        "schema": "ajax.display_diag.v1",
        "ts": time.time(),
        "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "driver_url": driver_url,
        "rail": rail,
        "results": results,
    }
    out_path.write_text(json.dumps(receipt, ensure_ascii=True, indent=2) + "\n", encoding="utf-8")
    print(json.dumps({"ok": True, "path": str(out_path), "results": results}, ensure_ascii=False, indent=2))
    return 0

def _handle_lab_snap_request(
    root_dir: Path,
    *,
    job_id: str,
    active_window: bool = False,
    with_vision: bool = False,
    display_override: Optional[str] = None,
) -> Optional[dict]:
    if capture_lab_snapshot is None:
        print("Snap LAB no disponible (lab_snap no importable).")
        return None
    try:
        store = LabStateStore(root_dir)
        job, job_path = store.load_job(str(job_id))
    except Exception as exc:
        print(f"❌ LAB snap falló: job_no_encontrado ({exc})")
        return None
    mission_id = job.get("mission_id") if isinstance(job, dict) else None
    driver_url = _resolve_lab_driver_url()
    try:
        result = capture_lab_snapshot(
            root_dir=root_dir,
            job_id=str(job_id),
            mission_id=str(mission_id) if mission_id else None,
            active_window=active_window,
            driver_url=driver_url,
            display_override=display_override,
        )
    except Exception as exc:
        print(f"❌ LAB snap falló: {exc} (driver={driver_url})")
        try:
            rel_job = os.path.relpath(job_path, root_dir) if root_dir else str(job_path)
            print(f"Refs (job): {rel_job}")
        except Exception:
            pass
        return None
    png_path = result.get("png_path")
    json_path = result.get("json_path")
    if png_path:
        try:
            rel = os.path.relpath(png_path, root_dir) if root_dir else str(png_path)
        except Exception:
            rel = str(png_path)
        print(f"📷 LAB snap guardado: {rel}")
    if json_path:
        try:
            rel = os.path.relpath(json_path, root_dir) if root_dir else str(json_path)
        except Exception:
            rel = str(json_path)
        print(f"Meta: {rel}")
    warnings = result.get("warnings") if isinstance(result, dict) else None
    if isinstance(warnings, list):
        for warn in warnings:
            if not isinstance(warn, dict):
                continue
            if warn.get("evidence_kind") == "scope_shared":
                detail = warn.get("detail") or "scope_shared"
                print(f"LAB SNAP WARNING: {detail}")
                if _ux_profile() == "debug":
                    lab = (
                        warn.get("lab_session") if isinstance(warn.get("lab_session"), dict) else {}
                    )
                    prod = (
                        warn.get("prod_session")
                        if isinstance(warn.get("prod_session"), dict)
                        else {}
                    )
                    print(
                        "LAB SNAP DEBUG: "
                        f"lab_session_id={lab.get('session_id')} lab_user={lab.get('user')} lab_driver={warn.get('lab_driver_url')}"
                    )
                    print(
                        "LAB SNAP DEBUG: "
                        f"prod_session_id={prod.get('session_id')} prod_user={prod.get('user')} prod_driver={warn.get('prod_driver_url')}"
                    )
    if with_vision and png_path:
        vision_summary = _describe_snapshot_with_vision(str(png_path))
        if vision_summary:
            print(f"VISION: {vision_summary}")
    return result


def _load_router_decision_summary(root_dir: Path, detail: dict) -> tuple[list[str], Optional[str]]:
    top_causes = detail.get("router_top_causes")
    if not isinstance(top_causes, list):
        top_causes = []
    trace_path = detail.get("router_trace_path")
    mission_id = detail.get("mission_id")
    trace_candidate = None
    if trace_path:
        try:
            trace_candidate = Path(trace_path)
            if not trace_candidate.is_absolute():
                trace_candidate = root_dir / trace_path
        except Exception:
            trace_candidate = None
    if trace_candidate is None and mission_id:
        candidate = root_dir / "artifacts" / "router" / f"decision_{mission_id}.json"
        if candidate.exists():
            trace_candidate = candidate
            try:
                trace_path = os.path.relpath(candidate, root_dir)
            except Exception:
                trace_path = str(candidate)
    if (not top_causes) and trace_candidate and trace_candidate.exists():
        try:
            payload = json.loads(trace_candidate.read_text(encoding="utf-8"))
            if isinstance(payload, dict):
                summary = payload.get("summary") if isinstance(payload.get("summary"), dict) else {}
                raw_causes = (
                    summary.get("top_causes") if isinstance(summary.get("top_causes"), list) else []
                )
                top_causes = [str(c) for c in raw_causes if c]
        except Exception:
            top_causes = top_causes or []
    return top_causes, trace_path


def _render_router_summary_lines(detail: dict, root_dir: Path) -> list[str]:
    top_causes, trace_path = _load_router_decision_summary(root_dir, detail)
    lines: list[str] = []
    if top_causes:
        lines.append(f"Causas principales: {', '.join(top_causes)}")
    else:
        fallback_reason = detail.get("router_all_failed_reason")
        if fallback_reason:
            lines.append(f"Causas principales: {fallback_reason}")
    if trace_path:
        try:
            if os.path.isabs(str(trace_path)):
                rel = os.path.relpath(trace_path, root_dir) if root_dir else str(trace_path)
            else:
                rel = str(trace_path)
        except Exception:
            rel = str(trace_path)
        lines.append(f"Refs (router): {rel}")
    return lines


def _render_action_result(
    result: "AjaxExecutionResult", root_dir: Path
) -> tuple[list[str], Optional[str]]:
    detail = result.detail if isinstance(result.detail, dict) else {}
    artifacts = result.artifacts if isinstance(result.artifacts, dict) else {}
    mission_log = artifacts.get("mission_log")
    debug = _ux_profile() == "debug"
    err = (result.error or "").strip()
    if err == "NO_PLAN":
        receipt_path = (
            detail.get("waiting_mission_path")
            or detail.get("waiting_payload_path")
            or artifacts.get("waiting_mission")
        )
        rel = None
        if receipt_path:
            try:
                rel = os.path.relpath(receipt_path, root_dir) if root_dir else str(receipt_path)
            except Exception:
                rel = str(receipt_path)
        lines = ["⚠️ No pude generar un plan válido."]
        if rel:
            lines.append(f"Recibo: {rel}")
        lines.append("Opciones:")
        lines.append("   - :open_incident (recomendado)")
        lines.append("   - :park")
        lines.append("   - :close_manual_done")
        return lines, "No pude generar un plan válido."
    if err == "PAUSED_FOR_LAB":
        job_id = detail.get("lab_job_id") or "desconocido"
        status = detail.get("status") or "QUEUED"
        objective = detail.get("objective") or ""
        output_paths = detail.get("output_paths") or []
        rel_paths = []
        if debug:
            for path in output_paths:
                if not path:
                    continue
                try:
                    rel_paths.append(os.path.relpath(path, root_dir) if root_dir else str(path))
                except Exception:
                    rel_paths.append(str(path))
        lines = [f"[LAB HANDOFF] job={job_id} status={status}"]
        if objective:
            lines.append(f"Objetivo: {objective}")
        if debug and rel_paths:
            lines.append(f"Refs: {', '.join(rel_paths[:4])}")
        if debug:
            try:
                _info, lab_lines = _lab_status_lines(root_dir, str(job_id))
                lines.extend(lab_lines)
            except Exception:
                pass
            lines.extend(_render_router_summary_lines(detail, root_dir))
        lines.append(f"Accion: ajaxctl lab status {job_id} | ajaxctl lab acknowledge {job_id}")
        lines.append(
            "Responde con [wait_lab], [status], [resume], [cancel], [snap] o [snap_lab] para continuar la mision."
        )
        return lines, "Mision derivada a LAB."
    if err in {"CANCELLED", "ABORTED_BY_USER"}:
        job_id = detail.get("lab_job_id")
        job_status = detail.get("lab_job_status")
        job_action = detail.get("lab_job_action")
        headline = "⛔ Misión cancelada."
        if err == "ABORTED_BY_USER":
            headline = "⛔ Misión abortada por el usuario."
        lines = [headline]
        if job_id:
            suffix = []
            if job_status:
                suffix.append(f"status={job_status}")
            if job_action:
                suffix.append(str(job_action))
            suffix_txt = f" ({' · '.join(suffix)})" if suffix else ""
            lines.append(f"Job: {job_id}{suffix_txt}")
        if debug:
            lines.extend(_render_router_summary_lines(detail, root_dir))
        lines.append("Accion: ninguna (mision cancelada).")
        return lines, "Mision cancelada."
    if err == "BLOCKED_BY_MISSING_PLAYERS":
        missing_players = detail.get("missing_players")
        slots_missing = detail.get("slots_missing")
        fix_hints = detail.get("fix_hints") or "unknown"
        gap_path = (
            detail.get("gap_path")
            or artifacts.get("capability_gap")
            or detail.get("starting_xi_path")
        )
        lines = ["⛔ BLOCKED: faltan jugadores requeridos (no se ejecuta)."]
        if isinstance(missing_players, list):
            try:
                lines.append("missing_players=" + json.dumps(missing_players, ensure_ascii=False))
            except Exception:
                lines.append(f"missing_players={_shorten(missing_players)}")
        if isinstance(slots_missing, list):
            try:
                lines.append("slots_missing=" + json.dumps(slots_missing, ensure_ascii=False))
            except Exception:
                lines.append(f"slots_missing={_shorten(slots_missing)}")
        lines.append(f"Fix hints: {fix_hints} (auth/quota/timeout)")
        if gap_path and debug:
            try:
                rel = os.path.relpath(gap_path, root_dir) if root_dir else str(gap_path)
            except Exception:
                rel = str(gap_path)
            lines.append(f"Detalle estructurado: {rel}")
        return lines, "No puedo ejecutar: faltan jugadores."
    if result.success:
        degraded = bool(detail.get("degraded")) if isinstance(detail, dict) else False
        if degraded:
            reason = str(detail.get("degraded_reason") or "unknown")
            label = "missing Vision" if reason == "missing_vision" else reason
            lines = [f"DEGRADED: {label}"]
            fix_steps = detail.get("fix_steps") if isinstance(detail, dict) else None
            if isinstance(fix_steps, list) and fix_steps:
                for step in fix_steps[:3]:
                    if step:
                        lines.append(f"- {str(step)}")
            lines.append("✅ Hecho.")
            return lines, "Hecho."
        extra = _shorten(detail or {})
        voice_line = f"Hecho. {extra}" if extra else "Hecho."
        return [f"✅ Hecho. {extra}" if extra else "✅ Hecho."], voice_line
    if (result.error or "").strip() == "await_user_input":
        question = detail.get("question") or "Esperando confirmación humana."
        expects = str(detail.get("expects") or "menu_choice").strip().lower()
        budget_exhausted = "[budget_exhausted]" in str(question).lower()
        loop_guard = bool(detail.get("loop_guard") or detail.get("loop_guard_triggered"))
        try:
            from agency.ux_waiting import render_waiting_panel
        except Exception:
            render_waiting_panel = None  # type: ignore
        compact = (os.getenv("AJAX_WAITING_PANEL") or "").strip().lower() == "compact"
        if render_waiting_panel is not None:
            lines = render_waiting_panel(
                detail,
                root_dir,
                debug=debug,
                compact=compact,
                has_lab_job=bool(_waiting_lab_job_id(root_dir)),
            )
        else:
            lines = [f"⏳ Esperando tu decisión: {question}"]
        return lines, f"Estoy esperando tu decisión: {question}"
    detail_txt = result.error or _shorten(detail or {})
    if mission_log:
        if debug:
            rel = os.path.relpath(mission_log, root_dir) if root_dir else mission_log
            line = f"❌ Fallo. {detail_txt} · Detalle estructurado en {rel}"
        else:
            line = f"❌ Fallo. {detail_txt}"
    else:
        line = f"❌ Fallo. {detail_txt}"
    voice_line = "He fallado. He guardado un log de misión." if mission_log else "He fallado."
    return [line], voice_line


def _load_starting_xi(root_dir: Path) -> Optional[dict]:
    try:
        root = Path(root_dir)
        sx_path = root / "artifacts" / "health" / "starting_xi.json"
        if not sx_path.exists():
            return None
        data = json.loads(sx_path.read_text(encoding="utf-8"))
        return data if isinstance(data, dict) else None
    except Exception:
        return None


def _render_council_starting_xi_lines(starting_xi: dict) -> list[str]:
    council = starting_xi.get("council") if isinstance(starting_xi, dict) else None
    council = council if isinstance(council, dict) else {}

    def _fmt_player(primary: Any) -> str:
        if not isinstance(primary, dict):
            return "-"
        prov = str(primary.get("provider") or "-")
        model = primary.get("model")
        tier = str(primary.get("tier") or "").strip()
        label = f"{prov}:{model}" if model else prov
        if tier:
            label += f" ({tier})"
        return label

    def _render_role(role_key: str) -> str:
        role = council.get(role_key) if isinstance(council, dict) else None
        role = role if isinstance(role, dict) else {}
        primary = role.get("primary")
        reason = role.get("reason")
        reason_txt = str(reason).strip() if reason is not None else ""
        if not reason_txt:
            reason_txt = "no_reason"
        return f"ROSTER: Council({role_key})={_fmt_player(primary)} reason={reason_txt}"

    return [_render_role("role1"), _render_role("role2")]


def _print_council_starting_xi_lines(root_dir: Path) -> None:
    if _ux_profile() != "debug":
        return
    sx = _load_starting_xi(root_dir)
    if not isinstance(sx, dict):
        return
    for line in _render_council_starting_xi_lines(sx):
        print(line)


def _render_council_invocation_line(result: Any, core_state: Any) -> str:
    invoked = None
    reason = None
    if result is not None and isinstance(getattr(result, "detail", None), dict):
        detail = result.detail
        if "council_invoked" in detail:
            invoked = detail.get("council_invoked")
            reason = detail.get("council_invoked_reason")
    if invoked is None and core_state is not None:
        notes = getattr(core_state, "notes", None)
        if isinstance(notes, dict) and "council_invoked" in notes:
            invoked = notes.get("council_invoked")
            reason = notes.get("council_invoked_reason")
    if invoked is None:
        invoked = False
        reason = "unknown"
    label = "yes" if invoked else "no"
    reason_txt = str(reason or "unknown")
    return f"COUNCIL INVOKED: {label} (reason={reason_txt})"


def _print_council_invocation_line(result: Any, core_state: Any) -> None:
    if _ux_profile() != "debug":
        return
    try:
        print(_render_council_invocation_line(result, core_state))
    except Exception:
        pass


def _lab_outcome_notice(root_dir: Path, *, limit: int = 1) -> list[str]:
    if str(os.getenv("AJAX_INTERACTIVE_CHAT") or "").strip().lower() in {"1", "true", "yes", "on"}:
        return []
    if not _env_truthy("AJAX_LAB_OUTCOME_NOTICE", default=True):
        return []
    try:
        store = LabStateStore(root_dir)
    except Exception:
        return []
    autoack_default = os.getenv("AJAX_INTERACTIVE_CHAT") == "1"
    autoack = _env_truthy("AJAX_LAB_OUTCOME_AUTOACK", default=autoack_default)
    pending = store.list_unacknowledged_results(limit=max(1, int(limit)) + 4)
    if not pending:
        return []
    for result, result_path in pending:
        job = None
        job_id = str(result.get("job_id") or "desconocido")
        mission_id = str(result.get("mission_id") or "")
        if autoack and mission_id == "doctor_lab":
            if job_id and job_id != "desconocido":
                try:
                    store.acknowledge_result(job_id)
                except Exception:
                    pass
            continue
        if job_id and job_id != "desconocido":
            try:
                job, _ = store.load_job(job_id)
            except Exception:
                job = None
        return _render_lab_outcome_lines(result, result_path, job, root_dir)
    return []


def _render_lab_outcome_lines(
    result: dict,
    result_path: Path,
    job: Optional[dict],
    root_dir: Path,
    *,
    include_actions: bool = True,
) -> list[str]:
    debug = _ux_profile() == "debug"
    job_id = str(result.get("job_id") or "desconocido")
    outcome = str(result.get("outcome") or "UNKNOWN")
    efe_pass = result.get("efe_pass")
    efe_label = "unknown"
    if isinstance(efe_pass, bool):
        efe_label = "yes" if efe_pass else "no"
    summary = _shorten(result.get("summary") or "", max_len=280)
    refs = result.get("evidence_refs") or []
    if (not refs) and isinstance(job, dict):
        refs = job.get("output_paths") or []
    rel_refs: list[str] = []
    for ref in refs:
        if not ref:
            continue
        try:
            rel_refs.append(os.path.relpath(ref, root_dir) if root_dir else str(ref))
        except Exception:
            rel_refs.append(str(ref))
    rel_result = None
    try:
        rel_result = os.path.relpath(result_path, root_dir) if root_dir else str(result_path)
    except Exception:
        rel_result = str(result_path)
    lines = [f"[LAB OUTCOME] job={job_id} outcome={outcome} efe_pass={efe_label}"]
    if summary:
        lines.append(f"Resumen: {summary}")
    if debug and rel_refs:
        lines.append(f"Refs: {', '.join(rel_refs[:4])}")
    if debug and rel_result:
        lines.append(f"Resultado: {rel_result}")
    if include_actions:
        lines.append(f"Accion: ajaxctl lab status {job_id} | ajaxctl lab acknowledge {job_id}")
    return lines


def _lab_outcome_summary_line(bundle: Optional[dict], root_dir: Path) -> Optional[str]:
    if not isinstance(bundle, dict):
        return None
    outcome = bundle.get("outcome") if isinstance(bundle.get("outcome"), dict) else {}
    outcome_raw = str(outcome.get("outcome") or "UNKNOWN").upper()
    if outcome_raw in {"PASS", "SUCCESS"}:
        label = "success"
    elif outcome_raw in {"FAIL", "FAILED"}:
        label = "fail"
    else:
        label = "stub"
    summary = _shorten(outcome.get("summary") or "", max_len=120)
    refs = outcome.get("evidence_refs") or []
    if not refs:
        job = bundle.get("job") if isinstance(bundle.get("job"), dict) else {}
        refs = job.get("output_paths") or []
    rel_refs: list[str] = []
    if isinstance(refs, list):
        for ref in refs:
            if not ref:
                continue
            try:
                rel_refs.append(os.path.relpath(ref, root_dir) if root_dir else str(ref))
            except Exception:
                rel_refs.append(str(ref))
    refs_txt = ", ".join(rel_refs[:3]) if rel_refs else "none"
    summary_txt = f" summary={summary}" if summary else ""
    return f"LAB resumen: {label} outcome={outcome_raw}{summary_txt} refs={refs_txt}"


def _load_waiting_payload(root_dir: Path) -> Optional[dict]:
    path = root_dir / "artifacts" / "state" / "waiting_mission.json"
    if not path.exists():
        return _resolve_latest_waiting_payload(root_dir)
    try:
        payload = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None
    if not isinstance(payload, dict):
        return None
    if str(payload.get("schema") or "").strip() != "ajax.waiting_mission.v1":
        return None
    if _waiting_payload_is_closed(payload):
        return _resolve_latest_waiting_payload(root_dir)
    status = str(payload.get("status") or "").strip().upper()
    if (
        status == "PAUSED_BY_USER"
        or bool(payload.get("paused_by_user"))
        or bool(payload.get("parked_by_user"))
    ):
        return _resolve_latest_waiting_payload(root_dir)
    payload["_path"] = str(path)
    return payload


def _waiting_payload_is_closed(payload: Optional[dict]) -> bool:
    if not isinstance(payload, dict):
        return True
    if "pending" in payload and payload.get("pending") is None:
        return True
    if payload.get("consumed_utc") or payload.get("consumed_at") or payload.get("consumed"):
        return True
    if payload.get("cancelled") or payload.get("cancelled_utc"):
        return True
    if payload.get("completed_manual") or payload.get("completed_manual_utc"):
        return True
    status = str(payload.get("status") or "").strip().upper()
    if status in {"CANCELLED", "DONE"}:
        return True
    return False


def _resolve_latest_waiting_payload(root_dir: Path) -> Optional[dict]:
    per_dir = root_dir / "artifacts" / "waiting_for_user"
    if not per_dir.exists():
        return None
    best_payload = None
    best_ts = ""
    for per_path in per_dir.glob("mission-*.json"):
        try:
            payload = json.loads(per_path.read_text(encoding="utf-8"))
        except Exception:
            continue
        if not isinstance(payload, dict):
            continue
        if _waiting_payload_is_closed(payload):
            continue
        status = str(payload.get("status") or "").strip().upper()
        if status == "PAUSED_BY_USER" or bool(payload.get("paused_by_user")):
            continue
        ts = payload.get("last_prompted_at") or payload.get("updated_utc") or ""
        if not ts:
            continue
        if ts > best_ts:
            best_ts = ts
            best_payload = payload
            best_payload["_path"] = str(per_path)
    if best_payload is None:
        return None
    best_payload["schema"] = "ajax.waiting_mission.v1"
    best_payload["mission_id"] = best_payload.get("mission_id") or Path(best_payload["_path"]).stem
    return best_payload


def _load_waiting_payload_from_mission(root_dir: Path, mission_id: str) -> Optional[dict]:
    if not mission_id:
        return None
    per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
    if not per_path.exists():
        return None
    try:
        payload = json.loads(per_path.read_text(encoding="utf-8"))
    except Exception:
        return None
    if not isinstance(payload, dict):
        return None
    if str(payload.get("schema") or "").strip() != "ajax.waiting_mission.v1":
        payload["schema"] = "ajax.waiting_mission.v1"
    payload["mission_id"] = payload.get("mission_id") or mission_id
    payload["_path"] = str(per_path)
    return payload


def _resolve_waiting_payload_for_mission(root_dir: Path, mission_id: str) -> Optional[dict]:
    payload = _load_waiting_payload(root_dir)
    if payload and str(payload.get("mission_id") or "") == str(mission_id):
        return payload
    return None


def _git_status_timeout_s() -> float:
    raw = (os.getenv("AJAX_GIT_STATUS_TIMEOUT") or "").strip()
    if not raw:
        return 2.5
    try:
        return max(0.5, float(raw))
    except Exception:
        return 2.5


def _truncate_output(text: str, limit: int = 4000) -> str:
    if text is None:
        return ""
    txt = str(text)
    if len(txt) <= limit:
        return txt
    return txt[:limit] + "…"


def _run_git_status(cwd: Path, *, timeout_s: float) -> Dict[str, Any]:
    modes = [
        ("full", ["git", "status", "--porcelain=v1", "-b"]),
        ("fallback_uno", ["git", "status", "--porcelain=v1", "-b", "-uno"]),
        ("fallback_diff", ["git", "diff", "--name-only"]),
    ]
    last_error = ""
    for idx, (mode, cmd) in enumerate(modes):
        t0 = time.monotonic()
        try:
            proc = subprocess.run(
                cmd,
                cwd=str(cwd),
                capture_output=True,
                text=True,
                timeout=timeout_s,
                check=False,
            )
            duration_ms = round((time.monotonic() - t0) * 1000, 2)
        except subprocess.TimeoutExpired:
            last_error = "timeout"
            if idx == 0:
                continue
            return {
                "status_mode": "timeout",
                "cmd": cmd,
                "exit_code": None,
                "duration_ms": round((time.monotonic() - t0) * 1000, 2),
                "stdout": "",
                "stderr": "timeout",
                "fallback_used": True,
            }
        except FileNotFoundError:
            return {
                "status_mode": "not_available",
                "cmd": cmd,
                "exit_code": None,
                "duration_ms": round((time.monotonic() - t0) * 1000, 2),
                "stdout": "",
                "stderr": "git_not_found",
                "fallback_used": idx > 0,
            }
        except Exception as exc:
            last_error = str(exc)
            if idx == 0:
                continue
            return {
                "status_mode": "error",
                "cmd": cmd,
                "exit_code": None,
                "duration_ms": round((time.monotonic() - t0) * 1000, 2),
                "stdout": "",
                "stderr": last_error,
                "fallback_used": True,
            }
        stdout = proc.stdout or ""
        stderr = proc.stderr or ""
        if proc.returncode != 0:
            err_txt = (stderr or stdout or "").lower()
            if "not a git repository" in err_txt or "not a git repository" in stdout.lower():
                return {
                    "status_mode": "not_repo",
                    "cmd": cmd,
                    "exit_code": proc.returncode,
                    "duration_ms": duration_ms,
                    "stdout": stdout,
                    "stderr": stderr,
                    "fallback_used": idx > 0,
                }
            last_error = f"exit_{proc.returncode}"
            if idx == 0:
                continue
            return {
                "status_mode": "error",
                "cmd": cmd,
                "exit_code": proc.returncode,
                "duration_ms": duration_ms,
                "stdout": stdout,
                "stderr": stderr or last_error,
                "fallback_used": True,
            }
        return {
            "status_mode": mode,
            "cmd": cmd,
            "exit_code": proc.returncode,
            "duration_ms": duration_ms,
            "stdout": stdout,
            "stderr": stderr,
            "fallback_used": idx > 0,
        }
    return {
        "status_mode": "error",
        "cmd": modes[-1][1],
        "exit_code": None,
        "duration_ms": 0.0,
        "stdout": "",
        "stderr": last_error or "unknown",
        "fallback_used": True,
    }


def _waiting_payload_is_parked(payload: Optional[dict]) -> bool:
    if not isinstance(payload, dict):
        return False
    status = str(payload.get("status") or "").strip().upper()
    return (
        bool(payload.get("paused_by_user"))
        or bool(payload.get("parked_by_user"))
        or status == "PAUSED_BY_USER"
    )


def _waiting_payload_budget_exhausted(payload: Optional[dict]) -> bool:
    if not isinstance(payload, dict):
        return False
    question = payload.get("pending_question") or payload.get("question") or ""
    return "[budget_exhausted]" in str(question).lower()


def _build_concierge_state(payload: Optional[dict]) -> Optional["ConciergeState"]:
    if ConciergeState is None or not isinstance(payload, dict):
        return None
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    question = payload.get("pending_question") or payload.get("question")
    expects = payload.get("expects") or mission_raw.get("expects")
    prompt_state = _load_waiting_prompt_state(ROOT, str(payload.get("mission_id") or "") or None)
    repeat_count = (
        int(prompt_state.get("repeat_count") or 0) if isinstance(prompt_state, dict) else 0
    )
    loop_guard = bool(prompt_state.get("loop_guard")) if isinstance(prompt_state, dict) else False
    budget_exhausted = _waiting_payload_budget_exhausted(payload)
    return ConciergeState(
        has_pending_mission=True,
        mission_id=str(payload.get("mission_id") or mission_raw.get("mission_id") or "") or None,
        intention=str(payload.get("intention") or mission_raw.get("intention") or "") or None,
        status=str(payload.get("status") or mission_raw.get("status") or "") or None,
        expects=str(expects).strip().lower() if expects else None,
        question=str(question) if question else None,
        budget_exhausted=budget_exhausted,
        lab_job_id=str(mission_raw.get("lab_job_id") or payload.get("lab_job_id") or "") or None,
        parked_by_user=_waiting_payload_is_parked(payload),
        repeat_count=repeat_count,
        loop_guard=loop_guard,
    )


def _render_pending_banner(
    payload: dict, *, mode: str, concierge: Optional["Concierge"]
) -> list[str]:
    if not isinstance(payload, dict):
        return []
    if concierge is None or ConciergeState is None:
        mission_id = payload.get("mission_id") or "desconocida"
        status = payload.get("status") or "WAITING_FOR_USER"
        return [f"Mision pendiente: {mission_id} (status={status})"]
    state = _build_concierge_state(payload)
    if state is None:
        return []
    resp = concierge.build_banner(state, mode=mode)
    lines: list[str] = []
    msg = str(resp.get("message") or "").strip()
    if msg:
        lines.extend(msg.splitlines())
    sugg = [s for s in (resp.get("suggestions") or []) if s]
    if sugg and not any("opciones:" in line.lower() for line in lines):
        lines.append("Opciones: " + " | ".join(sugg[:6]))
    return lines


def _should_route_waiting_input(
    *,
    line: str,
    chat_focus: str,
    waiting_payload: Optional[dict],
) -> bool:
    if not waiting_payload:
        return False
    cmd, _arg = _parse_bracket_command(line)
    if cmd:
        return True
    return str(chat_focus).startswith("mission")


def _next_chat_focus(current: str, cmd: str, mission_id: Optional[str]) -> str:
    cmd = (cmd or "").strip().lower()
    if cmd in {"chat", "back"}:
        return "chat"
    if cmd in {"mission", "resume"} and mission_id:
        return f"mission:{mission_id}"
    return current


def _should_ignore_waiting_for_direct_command(
    intent_gate: Optional[dict],
    chat_focus: str,
    waiting_payload: Optional[dict],
) -> bool:
    if not waiting_payload or not isinstance(intent_gate, dict):
        return False
    if str(chat_focus) != "chat":
        return False
    reason = str(intent_gate.get("reason") or "")
    return reason in {"direct_command", "slot_answer_commit", "commit_confirmed"}


def _load_waiting_prompt_state(root_dir: Path, mission_id: Optional[str]) -> dict:
    state: dict = {}
    payload = _load_waiting_payload(root_dir)
    if isinstance(payload, dict):
        state.update(
            {
                "pending_question": payload.get("pending_question") or payload.get("question"),
                "default_option_id": payload.get("default_option_id")
                or payload.get("default_option"),
                "expects": payload.get("expects"),
                "pending_default_confirm": payload.get("pending_default_confirm"),
                "last_question": payload.get("last_question"),
                "repeat_count": payload.get("repeat_count"),
                "loop_guard": payload.get("loop_guard"),
            }
        )
    if mission_id:
        try:
            per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
            if per_path.exists():
                doc = json.loads(per_path.read_text(encoding="utf-8"))
                if isinstance(doc, dict):
                    state.update(
                        {
                            "pending_question": doc.get("pending_question")
                            or state.get("pending_question"),
                            "default_option_id": doc.get("default_option_id")
                            or state.get("default_option_id"),
                            "expects": doc.get("expects") or state.get("expects"),
                            "pending_default_confirm": doc.get("pending_default_confirm")
                            if doc.get("pending_default_confirm") is not None
                            else state.get("pending_default_confirm"),
                            "last_question": doc.get("last_question") or state.get("last_question"),
                            "repeat_count": doc.get("repeat_count") or state.get("repeat_count"),
                            "loop_guard": doc.get("loop_guard")
                            if doc.get("loop_guard") is not None
                            else state.get("loop_guard"),
                        }
                    )
        except Exception:
            pass
    return state


def _update_waiting_prompt_state(root_dir: Path, mission_id: Optional[str], **fields: Any) -> None:
    payload = _load_waiting_payload(root_dir)
    if isinstance(payload, dict):
        payload.update(fields)
        payload["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
        path_txt = payload.get("_path") or (
            root_dir / "artifacts" / "state" / "waiting_mission.json"
        )
        try:
            path = Path(str(path_txt))
            path.write_text(
                json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
            )
        except Exception:
            pass
    if mission_id:
        try:
            per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
            if per_path.exists():
                doc = json.loads(per_path.read_text(encoding="utf-8"))
            else:
                doc = {}
            if isinstance(doc, dict):
                doc.update(fields)
                doc["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
                per_path.write_text(
                    json.dumps(doc, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
                )
        except Exception:
            pass


def _set_waiting_pause(
    root_dir: Path, mission_id: Optional[str], *, paused: bool, reason: Optional[str] = None
) -> None:
    if not mission_id:
        return
    payload = _load_waiting_payload(root_dir)
    if not payload and not paused:
        payload = _load_waiting_payload_from_mission(root_dir, str(mission_id))
    if not payload and paused:
        # Nothing to park in pointer file.
        return

    # Semantic state determination
    if paused:
        if reason == "commit_confirmed":
            status = "PAUSED_AUTO"
            p_by_user = False
        else:
            status = "PAUSED_BY_USER"
            p_by_user = True
    else:
        status = "WAITING_FOR_USER"
        p_by_user = False

    fields = {
        "paused_by_user": p_by_user,
        "parked_by_user": p_by_user,
        "status": status,
        "parked_reason": reason if paused else None,
        "paused_by_user_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
        if paused
        else None,
    }
    _update_waiting_prompt_state(root_dir, mission_id, **fields)
    if paused:
        try:
            path = root_dir / "artifacts" / "state" / "waiting_mission.json"
            if path.exists():
                path.unlink()
        except Exception:
            pass
    else:
        try:
            restored = _load_waiting_payload_from_mission(root_dir, str(mission_id))
            if restored:
                path = root_dir / "artifacts" / "state" / "waiting_mission.json"
                path.write_text(
                    json.dumps(restored, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
                )
        except Exception:
            pass
    _write_chat_receipt(
        root_dir,
        {
            "schema": "ajax.chat_event.v1",
            "ts": time.time(),
            "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "event": "mission_parked" if paused else "mission_resumed",
            "mission_id": mission_id,
            "status": status,
        },
    )


def _render_waiting_prompt_from_payload(payload: dict, root_dir: Path) -> list[str]:
    if not isinstance(payload, dict):
        return []
    try:
        from agency.ajax_core import AjaxExecutionResult
    except Exception:
        return []
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    detail = {
        "question": payload.get("pending_question") or payload.get("question"),
        "options": (
            payload.get("ask_user_payload", {}).get("options")
            if isinstance(payload.get("ask_user_payload"), dict)
            else None
        )
        or mission_raw.get("pending_user_options")
        or [],
        "default_option": payload.get("default_option_id") or payload.get("default_option"),
        "expects": payload.get("expects"),
        "waiting_mission_path": payload.get("_path"),
    }
    result = AjaxExecutionResult(
        success=False,
        error="await_user_input",
        detail=detail,
        path="waiting_for_user",
    )
    lines, _voice = _render_action_result(result, root_dir)
    return lines


def _execute_fresh_retry(
    root_dir: Path,
    core: "AjaxCore",
    payload: dict,
    *,
    execute_mission,
    answer_meta: Optional[Dict[str, Any]] = None,
    silent: bool = False,
) -> bool:
    if not isinstance(payload, dict):
        print("No hay misión pendiente.")
        return True
    mission_id = str(payload.get("mission_id") or "")
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    intention = str(payload.get("intention") or mission_raw.get("intention") or "").strip()
    mode = str(payload.get("mode") or mission_raw.get("mode") or "auto").strip().lower()
    if mode not in {"auto", "dry"}:
        mode = "auto"
    if not intention:
        print("No pude resolver el intent original para reintentar.")
        return True
    envelope_override = None
    envelope_raw = payload.get("envelope")
    if envelope_raw and isinstance(envelope_raw, dict):
        try:
            from agency.mission_envelope import MissionEnvelope
        except Exception:
            MissionEnvelope = None  # type: ignore
        if MissionEnvelope is not None:
            try:
                envelope_obj = MissionEnvelope.from_dict(envelope_raw)
                envelope_override = core._clone_envelope_for_retry(
                    envelope_obj, retry_of=mission_id
                )
            except Exception:
                envelope_override = None
    if envelope_override is None:
        try:
            envelope_override = core._create_mission_envelope(intention, mode)
            if envelope_override and hasattr(envelope_override, "metadata"):
                try:
                    envelope_override.metadata["retry_of"] = mission_id
                    envelope_override.metadata["fresh_clone"] = True
                except Exception:
                    pass
        except Exception:
            envelope_override = None
    try:
        core._clear_waiting_mission(
            mission_id=mission_id, cancelled=True, cancel_reason="retry_fresh"
        )
    except Exception:
        pass
    if isinstance(answer_meta, dict):
        answer_meta.clear()
        answer_meta.update(
            {
                "retry_of": mission_id or None,
                "fresh_clone": True,
                "retry_new_mission_id": getattr(envelope_override, "mission_id", None)
                if envelope_override
                else None,
                "envelope_clone": bool(envelope_raw),
            }
        )
    prev_ignore = os.environ.get("AJAX_IGNORE_WAITING_MISSION")
    os.environ["AJAX_IGNORE_WAITING_MISSION"] = "1"
    try:
        if not silent:
            print("Procesando reintento como misión nueva…")
        execute_mission(
            intention,
            envelope_override=envelope_override,
            mission_mode=mode,
        )
    finally:
        if prev_ignore is None:
            os.environ.pop("AJAX_IGNORE_WAITING_MISSION", None)
        else:
            os.environ["AJAX_IGNORE_WAITING_MISSION"] = prev_ignore
    return True


def _waiting_lab_status_lines(root_dir: Path) -> list[str]:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        return []
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    job_id = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    if not job_id:
        return []
    _info, lines = _lab_status_lines(root_dir, str(job_id))
    return lines


def _inject_lab_outcome_into_waiting_payload(
    root_dir: Path, payload: dict, lab_outcome: dict
) -> None:
    if not isinstance(payload, dict) or not isinstance(lab_outcome, dict):
        return
    payload["lab_outcome"] = lab_outcome
    payload["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    path_txt = payload.get("_path") or (root_dir / "artifacts" / "state" / "waiting_mission.json")
    try:
        path = Path(str(path_txt))
        path.write_text(json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
    except Exception:
        pass
    mission_id = payload.get("mission_id")
    if mission_id:
        try:
            per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
            if per_path.exists():
                doc = json.loads(per_path.read_text(encoding="utf-8"))
            else:
                doc = {}
            if isinstance(doc, dict):
                doc["lab_outcome"] = lab_outcome
                doc["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
                per_path.write_text(
                    json.dumps(doc, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
                )
        except Exception:
            pass


def _clear_waiting_payload_for_job(root_dir: Path, job_id: str, *, cancel_reason: str) -> bool:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        return False
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    payload_job = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    if not payload_job or str(payload_job) != str(job_id):
        return False
    path_txt = payload.get("_path") or (root_dir / "artifacts" / "state" / "waiting_mission.json")
    try:
        path = Path(str(path_txt))
        if path.exists():
            path.unlink()
    except Exception:
        pass
    mission_id = payload.get("mission_id") or mission_raw.get("mission_id")
    if mission_id:
        try:
            per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
            if per_path.exists():
                doc = json.loads(per_path.read_text(encoding="utf-8"))
            else:
                doc = {}
            if isinstance(doc, dict):
                doc["consumed_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
                doc["cancelled"] = True
                doc["cancelled_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
                doc["cancel_reason"] = cancel_reason
                per_path.write_text(
                    json.dumps(doc, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
                )
        except Exception:
            pass
    return True


def _cancel_waiting_mission(
    core: "AjaxCore", root_dir: Path, *, question: Optional[str] = None
) -> bool:
    payload = core._load_waiting_mission_payload()
    if not payload:
        print("No hay mision en espera.")
        return False
    question = question or payload.get("question") or "Mision en espera."
    mission = None
    try:
        mission = core._mission_from_waiting_payload(payload)
    except Exception:
        mission = None
    if mission is not None:
        mission.last_user_reply = "[cancel]"
        try:
            core._handle_user_option_selection(
                mission,
                {"id": "cancel", "label": "Cancelar"},
                question=question,
                reason=None,
            )
        except Exception:
            mission = None
        else:
            result = mission.last_result
            if result is not None:
                lines, _voice_msg = _render_action_result(result, root_dir)
                for line in lines:
                    print(line)
            else:
                print("Mision cancelada.")
            return True
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    mission_id = payload.get("mission_id") or mission_raw.get("mission_id") or ""
    job_id = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    job_status = None
    job_action = "detached"
    if job_id and getattr(core, "lab_control", None):
        try:
            job, _path = core.lab_control.load_job(str(job_id))
            job_status = str(job.get("status") or "").upper()
            if job_status in {"QUEUED", "RUNNING"}:
                core.lab_control.cancel_job(str(job_id), reason="user_cancel")
                job_status = "CANCELLED"
                job_action = "cancelled"
        except Exception:
            job_status = None
            job_action = "detached"
    try:
        core._clear_waiting_mission(
            mission_id=str(mission_id) if mission_id else None,
            cancelled=True,
            cancel_reason="user_cancel",
        )
    except Exception:
        pass
    print("⛔ Mision cancelada.")
    if job_id:
        suffix = []
        if job_status:
            suffix.append(f"status={job_status}")
        if job_action:
            suffix.append(str(job_action))
        suffix_txt = f" ({' · '.join(suffix)})" if suffix else ""
        print(f"Job: {job_id}{suffix_txt}")
    return True


def _update_waiting_payload_job_id(root_dir: Path, old_job_id: str, new_job_id: str) -> bool:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        return False
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    payload_job = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    if not payload_job or str(payload_job) != str(old_job_id):
        return False
    mission_raw["lab_job_id"] = new_job_id
    payload["mission"] = mission_raw
    if "lab_job_id" in payload:
        payload["lab_job_id"] = new_job_id
    ask_payload = (
        payload.get("ask_user_payload") if isinstance(payload.get("ask_user_payload"), dict) else {}
    )
    context = ask_payload.get("context") if isinstance(ask_payload.get("context"), dict) else {}
    context["lab_job_id"] = new_job_id
    ask_payload["context"] = context
    payload["ask_user_payload"] = ask_payload
    payload["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    path_txt = payload.get("_path") or (root_dir / "artifacts" / "state" / "waiting_mission.json")
    try:
        path = Path(str(path_txt))
        path.write_text(json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
    except Exception:
        pass
    mission_id = payload.get("mission_id") or mission_raw.get("mission_id")
    if mission_id:
        try:
            per_path = root_dir / "artifacts" / "waiting_for_user" / f"{mission_id}.json"
            if per_path.exists():
                doc = json.loads(per_path.read_text(encoding="utf-8"))
            else:
                doc = {}
            payload_record = doc.get("payload") if isinstance(doc.get("payload"), dict) else {}
            ctx = (
                payload_record.get("context")
                if isinstance(payload_record.get("context"), dict)
                else {}
            )
            ctx["lab_job_id"] = new_job_id
            payload_record["context"] = ctx
            doc["payload"] = payload_record
            doc["updated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
            per_path.write_text(
                json.dumps(doc, ensure_ascii=False, indent=2) + "\n", encoding="utf-8"
            )
        except Exception:
            pass
    return True


def _materialize_lab_outcome(
    root_dir: Path, job_id: str, *, include_actions: bool = True
) -> Optional[dict]:
    try:
        store = LabStateStore(root_dir)
    except Exception:
        return None
    found = store.find_result_for_job(job_id)
    if not found:
        return None
    result, result_path = found
    job = None
    try:
        job, _ = store.load_job(job_id)
    except Exception:
        job = None
    lines = _render_lab_outcome_lines(
        result, result_path, job, root_dir, include_actions=include_actions
    )
    outcome_payload = {
        "job_id": job_id,
        "outcome": result.get("outcome"),
        "efe_pass": result.get("efe_pass"),
        "failure_codes": result.get("failure_codes"),
        "summary": result.get("summary"),
        "evidence_refs": result.get("evidence_refs"),
        "result_path": str(result_path),
        "job_status": job.get("status") if isinstance(job, dict) else None,
        "ack_required": result.get("ack_required"),
        "ack_status": result.get("ack_status"),
        "risk_level": result.get("risk_level"),
    }
    return {"lines": lines, "outcome": outcome_payload, "job": job, "result_path": str(result_path)}


def _handle_waiting_input(
    root_dir: Path,
    core: "AjaxCore",
    line: str,
    *,
    execute_mission,
    answer_meta: Optional[Dict[str, Any]] = None,
) -> bool:
    waiting_eval = core.evaluate_waiting_user_reply(line)
    if not waiting_eval:
        return False
    status = waiting_eval.get("status")
    question = waiting_eval.get("question") or "Tengo una mision esperando tu decision."
    mission_id = waiting_eval.get("mission_id") or "desconocida"
    expects = str(waiting_eval.get("expects") or "menu_choice").strip().lower()
    cmd, cmd_arg = _parse_bracket_command(line)
    normalized = cmd or core._normalize_waiting_reply_text(line)
    stripped = (line or "").strip()
    prompt_state = _load_waiting_prompt_state(root_dir, mission_id)
    default_option = waiting_eval.get("default_option") or prompt_state.get("default_option_id")
    pending_default_confirm = bool(prompt_state.get("pending_default_confirm"))
    budget_exhausted = "[budget_exhausted]" in str(question).lower()
    last_question = prompt_state.get("last_question")
    repeat_count = int(prompt_state.get("repeat_count") or 0)
    loop_guard = bool(prompt_state.get("loop_guard"))
    if budget_exhausted:
        expects = "user_answer"
        default_option = "open_incident"
    if status == "invalid":
        if question and question == last_question:
            repeat_count += 1
        else:
            repeat_count = 1
        loop_guard = repeat_count >= 2
        _update_waiting_prompt_state(
            root_dir,
            mission_id,
            last_question=question,
            repeat_count=repeat_count,
            loop_guard=loop_guard,
        )
    else:
        if repeat_count or loop_guard:
            _update_waiting_prompt_state(
                root_dir,
                mission_id,
                repeat_count=0,
                loop_guard=False,
            )

    def _record_answer(mode: str, text: str) -> None:
        if answer_meta is None:
            return
        answer_meta.clear()
        answer_meta.update(
            {
                "answer_mode": mode,
                "user_answer_text": _truncate_answer(text),
            }
        )

    if pending_default_confirm and stripped:
        _update_waiting_prompt_state(root_dir, mission_id, pending_default_confirm=False)

    if normalized == "status":
        lines = _waiting_lab_status_lines(root_dir)
        if lines:
            for lab_line in lines:
                print(lab_line)
        else:
            print(f"Misión {mission_id} en espera (WAITING_FOR_USER).")
            print(f"Pregunta: {question}")
            if expects == "user_answer":
                print("Responde escribiendo texto o usa [answer] <texto>.")
            print("No hay job LAB. Puedes contestar en texto normal o usar [answer] <texto>.")
            base_opts = "[close_manual_done] [open_incident] [snap] [snap+vision]"
            if loop_guard:
                base_opts = "[close_manual_done] [open_incident] [park] [snap] [snap+vision]"
            print(f"Opciones: {base_opts}")
            if loop_guard and budget_exhausted:
                print("Opciones extra: [retry_fresh]")
        return True

    if normalized in {"ack", "ack_lab", "acknowledge"}:
        payload, _mission_id, job_id = _resolve_waiting_context(root_dir)
        if not job_id:
            print("No hay job LAB activo para reconocer.")
            print(
                "Si quieres contestar la pregunta, escribe tu respuesta en texto o usa [answer] <texto>."
            )
            return True
        try:
            store = LabStateStore(root_dir)
            ack_path = store.acknowledge_result(str(job_id))
            if ack_path:
                print(f"ACK registrado: {ack_path}")
            else:
                print("No hay outcome LAB para reconocer.")
        except Exception as exc:
            print(f"ACK falló: {exc}")
        return True

    if normalized in {"ack_user", "ack-user"}:
        answer_text = cmd_arg or "ack"
        _record_answer("bracket_command", answer_text)
        print("Procesando tu respuesta para la misión pendiente…")
        execute_mission(answer_text)
        return True

    if normalized in {"retry_fresh", "retry-fresh"}:
        payload = core._load_waiting_mission_payload()
        if not payload:
            print("No hay misión pendiente.")
            return True
        return _execute_fresh_retry(
            root_dir,
            core,
            payload,
            execute_mission=execute_mission,
            answer_meta=answer_meta,
        )

    if normalized in {"park", "pause"}:
        payload = core._load_waiting_mission_payload()
        if not payload:
            print("No hay misión pendiente para aparcar.")
            return True
        mission_id = payload.get("mission_id") or payload.get("mission", {}).get("mission_id")
        if not mission_id:
            print("No pude resolver el mission_id para aparcar.")
            return True
        _set_waiting_pause(root_dir, str(mission_id), paused=True)
        print(f"Misión aparcada: {mission_id}")
        return True

    if normalized == "answer":
        if not cmd_arg:
            print("Uso: [answer] <texto>")
            return True
        _record_answer("bracket_command", cmd_arg)
        print("Procesando tu respuesta para la misión pendiente…")
        execute_mission(cmd_arg)
        return True

    if normalized in {"close_manual_done", "close_manual"}:
        payload = core._load_waiting_mission_payload()
        if not payload:
            print("No hay mision en espera.")
            return True
        mission = None
        try:
            mission = core._mission_from_waiting_payload(payload)
        except Exception:
            mission = None
        if mission is None:
            print("No pude rehidratar la misión. Abre INCIDENT para triage.")
            return True
        mission.last_user_reply = "[close_manual_done]"
        core._handle_user_option_selection(
            mission,
            {"id": "close_manual_done", "label": "Cerrar misión manualmente"},
            question=question,
            reason="manual_close",
        )
        result = mission.last_result
        if result is not None:
            lines, _voice_msg = _render_action_result(result, root_dir)
            for line in lines:
                print(line)
        receipt_path = _write_exec_receipt(
            root_dir,
            {
                "schema": "ajax.exec_receipt.v1",
                "ts": time.time(),
                "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "verify_ok": True,
                "error": None,
                "path": "manual_close",
                "intent": "[close_manual_done]",
                "mission_id": mission.mission_id,
                "outcome": "manual_done",
                "reason": "user_confirmed",
            },
        )
        if receipt_path:
            try:
                rel = os.path.relpath(receipt_path, root_dir) if root_dir else str(receipt_path)
            except Exception:
                rel = str(receipt_path)
            print(f"Resumen: OK receipt={rel}")
        return True

    if normalized in {"snap_lab", "snap_lab+vision"}:
        payload, _mission_id, job_id = _resolve_waiting_context(root_dir)
        if not job_id:
            print("No hay job LAB activo para adjuntar snap.")
            return True
        _handle_lab_snap_request(
            root_dir,
            job_id=str(job_id),
            active_window=False,
            with_vision=normalized.endswith("+vision"),
        )
        return True

    if normalized == "cancel":
        _cancel_waiting_mission(core, root_dir, question=question)
        return True

    if normalized == "wait_lab":
        print("Esperando outcome LAB para la mision pendiente...")
        _wait_for_lab_and_resume(root_dir, execute_mission=execute_mission)
        return True

    if not stripped:
        enter_behavior = _waiting_enter_behavior()
        try:
            from agency.ux_waiting import resolve_enter_default
        except Exception:
            resolve_enter_default = None  # type: ignore
        if resolve_enter_default is not None:
            action, new_pending, message = resolve_enter_default(
                stripped=stripped,
                default_option=default_option,
                pending_default_confirm=pending_default_confirm,
                enter_behavior=enter_behavior,
            )
            _update_waiting_prompt_state(root_dir, mission_id, pending_default_confirm=new_pending)
            if action == "confirm":
                print(message)
                return True
            if action == "execute":
                print("Procesando tu respuesta para la misión pendiente…")
                execute_mission(message)
                return True
            if message:
                print(message)
                return True
        if enter_behavior == "default" and default_option:
            if not pending_default_confirm:
                _update_waiting_prompt_state(root_dir, mission_id, pending_default_confirm=True)
                print(f"Pulsa Enter otra vez para confirmar default: [{default_option}]")
                return True
            _update_waiting_prompt_state(root_dir, mission_id, pending_default_confirm=False)
            print("Procesando tu respuesta para la misión pendiente…")
            execute_mission(f"[{default_option}]")
            return True
        print("Escribe tu respuesta o usa un comando entre corchetes.")
        return True

    if budget_exhausted and cmd is None and stripped:
        lowered = stripped.lower()
        if any(tok in lowered for tok in {"incidente", "incident"}):
            print("Procesando tu respuesta para la misión pendiente…")
            execute_mission("[open_incident]")
            return True
        if any(tok in lowered for tok in {"cerrar", "close", "manual"}):
            print("Procesando tu respuesta para la misión pendiente…")
            execute_mission("[close_manual_done]")
            return True
        try:
            payload = core._load_waiting_mission_payload()
            intent = None
            if isinstance(payload, dict):
                intent = payload.get("intention")
            if intent:
                print(f"Misión en espera: {mission_id}")
                print(f"Intent: {intent}")
        except Exception:
            pass
        print(
            "Presupuesto agotado: no puedo reintentar igual. Usa [open_incident] o [close_manual_done]."
        )
        return True

    if (expects == "user_answer") and cmd is None:
        _record_answer("free_text", stripped)
        print("Procesando tu respuesta para la misión pendiente…")
        execute_mission(stripped)
        return True

    if status == "invalid":
        print(f"⚠️  Misión {mission_id} sigue en espera: {question}")
        options = waiting_eval.get("options") or []
        if loop_guard and isinstance(options, list):
            options = [
                opt for opt in options if "retry_escalate" not in str(opt.get("id") or "").lower()
            ]
        if options:
            print("Responde con una de las opciones usando el formato [opcion_id]:")
            for opt in options:
                opt_id = opt.get("id") or "opcion"
                label = opt.get("label") or ""
                print(f"   - [{opt_id}] {label}".rstrip())
            if expects == "user_answer" or budget_exhausted:
                print("   - Responde escribiendo texto, o usa [answer] <texto>")
            print("   - [status] Ver estado de LAB (si aplica)")
            print("   - [ack] Reconocer outcome LAB (si aplica)")
            print("   - [ack_user] Confirmar acción manual (sin LAB)")
            option_ids = {
                str(opt.get("id") or "").strip().lower() for opt in options if isinstance(opt, dict)
            }
            if "close_manual_done" not in option_ids:
                print("   - [close_manual_done] Cerrar misión manualmente (sin LAB)")
            if loop_guard and "park" not in option_ids:
                print("   - [park] Aparcar misión y volver a chat")
            if loop_guard and not budget_exhausted and "retry_fresh" not in option_ids:
                print("   - [retry_fresh] Reintentar como nueva misión (loop guard)")
            if loop_guard and budget_exhausted and "retry_fresh" not in option_ids:
                print("   - [retry_fresh] Reintentar como nueva misión (loop guard)")
            print("   - [snap] Capturar screenshot del escritorio")
            print("   - [snap+vision] Capturar y describir con vision (opcional)")
            payload, _wait_mission, wait_job = _resolve_waiting_context(root_dir)
            if wait_job:
                print("   - [snap_lab] Capturar screenshot del escritorio LAB")
                print("   - [snap_lab+vision] Capturar y describir LAB con vision (opcional)")
            if default_option:
                print(f"   (Opción por defecto: {default_option})")
        else:
            print("Envia una respuesta clara para desbloquear la mision.")
        if _ux_profile() == "debug":
            for lab_line in _waiting_lab_status_lines(root_dir):
                print(lab_line)
        return True

    if status == "resume":
        print("Procesando tu respuesta para la misión pendiente…")
        resume_text = "[resume]" if normalized == "resume" else line
        execute_mission(resume_text)
        return True

    return True


def _wait_for_lab_and_resume(
    root_dir: Path,
    *,
    execute_mission,
    poll_sec: Optional[float] = None,
    max_sec: Optional[float] = None,
    sleep_fn=time.sleep,
) -> bool:
    payload = _load_waiting_payload(root_dir)
    if not payload:
        print("No hay mision en espera.")
        return True
    mission_raw = payload.get("mission") if isinstance(payload.get("mission"), dict) else {}
    mission_id = payload.get("mission_id") or mission_raw.get("mission_id") or "desconocida"
    job_id = mission_raw.get("lab_job_id") or payload.get("lab_job_id")
    if not job_id:
        print(f"No hay job LAB activo para la mision {mission_id}.")
        return True
    try:
        store = LabStateStore(root_dir)
    except Exception:
        print("LAB no disponible.")
        return True
    if poll_sec is None:
        try:
            poll_sec = float(os.getenv("AJAX_LAB_WAIT_POLL_SEC", "3") or 3)
        except Exception:
            poll_sec = 3.0
    if max_sec is None:
        try:
            max_sec = float(os.getenv("AJAX_LAB_WAIT_MAX_SEC", "0") or 0)
        except Exception:
            max_sec = 0.0
    start = time.time()
    last_status = None
    try:
        while True:
            bundle = _materialize_lab_outcome(root_dir, str(job_id), include_actions=False)
            if bundle:
                for line in bundle.get("lines") or []:
                    print(line)
                summary_line = _lab_outcome_summary_line(bundle, root_dir)
                if summary_line:
                    print(summary_line)
                try:
                    ack_path = store.acknowledge_result(str(job_id))
                    if ack_path:
                        outcome = bundle.get("outcome")
                        if isinstance(outcome, dict):
                            outcome["acknowledged_path"] = str(ack_path)
                except Exception:
                    pass
                try:
                    outcome = bundle.get("outcome")
                    if isinstance(outcome, dict):
                        _inject_lab_outcome_into_waiting_payload(root_dir, payload, outcome)
                except Exception:
                    pass
                print("Procesando resultado LAB y reanudando...")
                execute_mission("[resume]")
                return True
            info = None
            status_txt = "UNKNOWN"
            try:
                job, job_path = store.load_job(str(job_id))
                info = store.annotate_job_staleness(job, job_path)
                status_txt = str(info.get("status") or job.get("status") or "UNKNOWN")
            except Exception:
                info = None
                status_txt = "UNKNOWN"
            if info:
                status_line = (
                    f"Estoy probando en LAB... (estado: {status_txt}, "
                    f"edad: {_fmt_age(info.get('job_age_s'))}, "
                    f"heartbeat: {_fmt_age(info.get('heartbeat_age_s'))})"
                )
            else:
                status_line = f"Estoy probando en LAB... (estado: {status_txt})"
            if status_line != last_status:
                print(status_line)
                last_status = status_line
            if info and info.get("is_stale"):
                reason = info.get("reason") or "unknown"
                print(
                    f"LAB: STALE (reason={reason}) status={status_txt} "
                    f"job_age={_fmt_age(info.get('job_age_s'))} "
                    f"heartbeat_age={_fmt_age(info.get('heartbeat_age_s'))} job_id={job_id}"
                )
                try:
                    rel_job = os.path.relpath(job_path, root_dir) if root_dir else str(job_path)
                    print(f"Refs (job): {rel_job}")
                except Exception:
                    pass
                print("Opciones: [cancel_job] [requeue_job] [open_incident]")
                return True
            if status_txt.upper() in {"CANCELLED", "FAILED", "DONE"}:
                print(f"LAB termino sin resultado registrado para job {job_id}.")
                print(f"Accion: ajaxctl lab status {job_id}")
                return True
            if max_sec and (time.time() - start) >= max_sec:
                print("LAB sigue en progreso; vuelve a intentar con [wait_lab].")
                return True
            sleep_fn(max(0.5, float(poll_sec or 0.0)))
    except KeyboardInterrupt:
        print("Interrumpido. Dejo el job en cola; estado no cambia.")
        return True


def _load_model_utility() -> Optional[dict]:
    cfg_path = ROOT / "config" / "model_utility.yaml"
    out_path = ROOT / "artifacts" / "model_utility" / "latest.json"
    needs_refresh = not out_path.exists()
    if cfg_path.exists() and out_path.exists():
        try:
            if cfg_path.stat().st_mtime > out_path.stat().st_mtime:
                needs_refresh = True
        except Exception:
            needs_refresh = True
    if needs_refresh and cfg_path.exists():
        try:
            cmd = [
                sys.executable,
                str(ROOT / "scripts" / "model_utility_compile.py"),
                "--in",
                str(cfg_path),
                "--out",
                str(out_path),
            ]
            subprocess.run(cmd, check=False, capture_output=True, text=True)
        except Exception:
            pass
    if not out_path.exists():
        return None
    try:
        data = json.loads(out_path.read_text(encoding="utf-8"))
        return data if isinstance(data, dict) else None
    except Exception:
        return None


def _load_provider_catalog_web() -> dict:
    path = ROOT / "artifacts" / "providers_catalog_web.json"
    if not path.exists():
        return {}
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def _load_ledger_latest() -> dict:
    path = ROOT / "artifacts" / "provider_ledger" / "latest.json"
    if not path.exists():
        return {}
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def _summarize_ledger_status(statuses: set[str]) -> str:
    if not statuses:
        return "unknown"
    if "hard_fail" in statuses:
        return "hard_fail"
    if "soft_fail" in statuses:
        return "soft_fail"
    if "ok" in statuses:
        return "ok"
    return ",".join(sorted(statuses))


def _collect_models_available() -> tuple[list[dict], list[str]]:
    errors: list[str] = []
    items: list[dict] = []
    try:
        from agency import models_registry
    except Exception as exc:
        return [], [f"models_registry_import_failed: {exc}"]
    try:
        models = models_registry.discover_models()
    except Exception as exc:
        return [], [f"models_registry_failed: {exc}"]
    seen: set[tuple[str, str]] = set()
    for m in models:
        provider = getattr(m, "provider", None)
        model_id = getattr(m, "id", None)
        if not provider or not model_id:
            continue
        key = (str(provider), str(model_id))
        if key in seen:
            continue
        seen.add(key)
        items.append(
            {
                "provider": str(provider),
                "model": str(model_id),
                "source": getattr(m, "source", "unknown"),
                "modalities": getattr(m, "modalities", None),
            }
        )
    items.sort(key=lambda r: (r.get("provider") or "", r.get("model") or ""))
    return items, errors


def cmd_models_available(args: argparse.Namespace) -> int:
    items, errors = _collect_models_available()
    if errors:
        for err in errors:
            print(err, file=sys.stderr)
        if not items:
            return 2

    catalog = _load_provider_catalog_web()
    providers = catalog.get("providers") if isinstance(catalog, dict) else {}
    seen_providers = set()
    if isinstance(providers, dict):
        for name, info in providers.items():
            if not isinstance(info, dict):
                continue
            sources = info.get("sources") or []
            ok = bool(info.get("ok"))
            if ok and isinstance(sources, list) and sources:
                seen_providers.add(str(name))

    ledger = _load_ledger_latest()
    rows = ledger.get("rows") if isinstance(ledger, dict) else []
    ledger_map: dict[tuple[str, str], dict[str, set[str]]] = {}
    if isinstance(rows, list):
        for row in rows:
            if not isinstance(row, dict):
                continue
            provider = row.get("provider")
            model = row.get("model")
            if not provider or not model:
                continue
            key = (str(provider), str(model))
            entry = ledger_map.setdefault(key, {"statuses": set(), "reasons": set()})
            status = row.get("status")
            reason = row.get("reason")
            if status:
                entry["statuses"].add(str(status))
            if reason:
                entry["reasons"].add(str(reason))

    if getattr(args, "json", False):
        payload = []
        for item in items:
            key = (item.get("provider") or "", item.get("model") or "")
            ledger_entry = ledger_map.get((str(key[0]), str(key[1])), {})
            status = _summarize_ledger_status(ledger_entry.get("statuses", set()))
            payload.append(
                {
                    **item,
                    "ledger_status": status,
                    "seen_in_catalog": (item.get("provider") or "") in seen_providers,
                }
            )
        print(json.dumps({"models": payload, "errors": errors}, ensure_ascii=False, indent=2))
        return 0

    print("provider\tmodel\tledger_status\tseen_in_catalog")
    for item in items:
        provider = str(item.get("provider") or "")
        model = str(item.get("model") or "")
        ledger_entry = ledger_map.get((provider, model), {})
        status = _summarize_ledger_status(ledger_entry.get("statuses", set()))
        seen = "yes" if provider in seen_providers else "no"
        print("\t".join([provider, model, status, seen]))
    return 0


def _load_model_utility_yaml(path: Path) -> tuple[dict, Optional[str]]:
    try:
        import yaml  # type: ignore
    except Exception:
        return {}, "pyyaml_not_available"
    if not path.exists():
        return {}, None
    try:
        data = yaml.safe_load(path.read_text(encoding="utf-8")) or {}
        return data if isinstance(data, dict) else {}, None
    except Exception as exc:
        return {}, str(exc)


def _write_model_utility_yaml(path: Path, data: dict) -> Optional[str]:
    try:
        import yaml  # type: ignore
    except Exception:
        return "pyyaml_not_available"
    try:
        path.write_text(
            yaml.safe_dump(data, sort_keys=False, allow_unicode=False),
            encoding="utf-8",
        )
        return None
    except Exception as exc:
        return str(exc)


def _bootstrap_model_utility(cfg_path: Path, items: list[dict]) -> tuple[int, int, Optional[str]]:
    data, err = _load_model_utility_yaml(cfg_path)
    if err:
        return 0, 0, err
    version = int(data.get("version") or 1)
    models = data.get("models")
    if not isinstance(models, list):
        models = []
    existing = {(m.get("provider"), m.get("model")) for m in models if isinstance(m, dict)}
    added = 0
    for item in items:
        provider = item.get("provider")
        model_id = item.get("model")
        if not provider or not model_id:
            continue
        key = (provider, model_id)
        if key in existing:
            continue
        models.append(
            {
                "provider": provider,
                "model": model_id,
                "status": "unknown",
                "roles": {},
                "constraints": {},
                "economics": {},
                "evidence": {"ledger_signals": [], "runs": []},
                "score": {},
            }
        )
        existing.add(key)
        added += 1
    data["version"] = version
    data["updated_at"] = time.strftime("%Y-%m-%d", time.gmtime())
    data["models"] = models
    err = _write_model_utility_yaml(cfg_path, data)
    if err:
        return added, len(models), err
    return added, len(models), None


def cmd_models_utility_show(args: argparse.Namespace) -> int:
    payload = _load_model_utility()
    if not payload:
        print(
            "No hay model_utility compilado. Ejecuta scripts/model_utility_compile.py.",
            file=sys.stderr,
        )
        return 2
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
        return 0
    print("provider\tmodel\tstatus\troles\tutility\tconfidence\tledger_signals")
    for item in payload.get("models") or []:
        if not isinstance(item, dict):
            continue
        roles = item.get("roles") or {}
        role_chunks = []
        if isinstance(roles, dict):
            for role in sorted(roles.keys()):
                fit = None
                if isinstance(roles.get(role), dict):
                    fit = roles.get(role).get("fit")
                role_chunks.append(f"{role}={fit or 'unknown'}")
        roles_summary = ",".join(role_chunks)
        score = item.get("score") or {}
        utility = score.get("utility") if isinstance(score, dict) else None
        confidence = score.get("confidence") if isinstance(score, dict) else None
        evidence = item.get("evidence") or {}
        ledger = evidence.get("ledger_signals") if isinstance(evidence, dict) else []
        if not isinstance(ledger, list):
            ledger = []
        print(
            "\t".join(
                [
                    str(item.get("provider") or ""),
                    str(item.get("model") or ""),
                    str(item.get("status") or ""),
                    roles_summary,
                    str(utility) if utility is not None else "",
                    str(confidence) if confidence is not None else "",
                    ",".join(str(x) for x in ledger if x),
                ]
            )
        )
    return 0


def cmd_models_utility_bootstrap(args: argparse.Namespace) -> int:
    items, errors = _collect_models_available()
    if errors:
        for err in errors:
            print(err, file=sys.stderr)
        if not items:
            return 2
    cfg_path = ROOT / "config" / "model_utility.yaml"
    added, total, err = _bootstrap_model_utility(cfg_path, items)
    if err:
        print(f"bootstrap_failed: {err}", file=sys.stderr)
        return 2
    payload = {"ok": True, "added": added, "total": total, "path": str(cfg_path)}
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        print(f"bootstrap ok: added={added} total={total} path={cfg_path}")
    return 0


def cmd_models_utility(args: argparse.Namespace) -> int:
    action = getattr(args, "action", "show")
    if action == "bootstrap":
        return cmd_models_utility_bootstrap(args)
    return cmd_models_utility_show(args)


def cmd_chat(args: argparse.Namespace) -> int:
    if getattr(args, "tier", None):
        os.environ["AJAX_COST_MODE"] = str(args.tier).strip().lower()
    elif not os.getenv("AJAX_COST_MODE"):
        os.environ["AJAX_COST_MODE"] = _default_cost_mode(ROOT)
    if getattr(args, "allow_local_text", False) or getattr(args, "allow_local", False):
        os.environ["AJAX_ALLOW_LOCAL_TEXT"] = "1"
    if getattr(args, "chat_lite", False):
        os.environ["AJAX_CHAT_LITE"] = "1"
    if getattr(args, "no_chat_lite", False):
        os.environ["AJAX_CHAT_LITE"] = "0"
    if "AJAX_CHAT_LITE" not in os.environ and _is_wsl() and _is_interactive():
        os.environ["AJAX_CHAT_LITE"] = "1"
    chat_lite_enabled = (os.getenv("AJAX_CHAT_LITE") or "").strip().lower() not in {
        "0",
        "false",
        "off",
        "no",
    }
    debug_enabled = (os.getenv("AJAX_CHAT_DEBUG") or "").strip().lower() in {
        "1",
        "true",
        "yes",
        "on",
    }
    session_mode = _chat_start_mode()
    chat_focus = "chat"
    pending_policy = _pending_mission_policy()
    concierge = None
    core = None
    chat_core = None
    scout = None
    voice: Optional[Voice] = None
    if getattr(args, "voice", False):
        if Voice is None:
            print("⚠️  Voz no disponible (agency.voice no importable).")
        else:
            voice = Voice()
    root_dir = ROOT
    t_init_chat_lite = None
    t_init_full_core = None
    jit_permit_pending: Optional[Dict[str, Any]] = None
    pending_answer_meta: Optional[Dict[str, Any]] = None

    def _local_llm_available() -> bool:
        try:
            import requests  # type: ignore
        except Exception:
            return False
        host = os.getenv("LMSTUDIO_HOST", "http://127.0.0.1:1234").rstrip("/")
        try:
            resp = requests.get(f"{host}/models", timeout=1.5)
            if resp.status_code >= 400:
                return False
            data = resp.json()
            return bool(data.get("models"))
        except Exception:
            return False

    def _concierge_local_llm(text: str, state: ConciergeState) -> Dict[str, Any]:
        try:
            import requests  # type: ignore
        except Exception:
            return {}
        host = os.getenv("LMSTUDIO_HOST", "http://127.0.0.1:1234").rstrip("/")
        prompt = (
            'Devuelve SOLO JSON con {"intent":"mission|park|open_incident|close_manual_done|mission_answer|chat",'
            '"answer_text":"..."}. Usa mission_answer si el usuario responde a una pregunta pendiente.'
            f"\nEstado: mission_id={state.mission_id} expects={state.expects} budget_exhausted={state.budget_exhausted}"
            f"\nTexto: {text}\n"
        )
        body = {
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.0,
            "max_tokens": 120,
            "stream": False,
        }
        try:
            resp = requests.post(f"{host}/chat/completions", json=body, timeout=10)
            if resp.status_code >= 400:
                return {}
            data = resp.json()
            choice = (data.get("choices") or [{}])[0]
            content = choice.get("message", {}).get("content") or ""
            parsed = json.loads(content)
            if isinstance(parsed, dict):
                return parsed
        except Exception:
            return {}
        return {}

    concierge_mode = _concierge_mode()
    if Concierge is not None:
        if concierge_mode == "local_llm" and _local_llm_available():
            concierge = Concierge(
                tone=_concierge_tone(), mode="local_llm", local_llm=_concierge_local_llm
            )
        else:
            concierge = Concierge(tone=_concierge_tone(), mode="heuristic")

    def _ensure_core() -> Optional[Any]:
        nonlocal core, scout, root_dir, t_init_full_core
        if core is not None:
            return core
        try:
            t0 = time.monotonic()
            core = _get_core()
            t_init_full_core = round((time.monotonic() - t0) * 1000, 2)
        except Exception as exc:
            print(str(exc), file=sys.stderr)
            return None
        root_dir = getattr(getattr(core, "config", None), "root_dir", None) or ROOT
        scout = Scout(
            ScoutConfig.default(
                root=getattr(core, "config", None).root_dir if hasattr(core, "config") else None
            )
        )
        return core

    def _ensure_chat_lite() -> Optional[Any]:
        nonlocal chat_core, root_dir, t_init_chat_lite
        if chat_core is not None:
            return chat_core
        try:
            t0 = time.monotonic()
            chat_core = _get_chat_lite()
            t_init_chat_lite = round((time.monotonic() - t0) * 1000, 2)
        except Exception as exc:
            print(str(exc), file=sys.stderr)
            return None
        root_dir = getattr(getattr(chat_core, "config", None), "root_dir", None) or ROOT
        return chat_core

    def _tty_sane():
        if not _is_interactive():
            return
        if os.name != "nt":
            try:
                subprocess.run(["stty", "sane"], check=False)
                subprocess.run(["stty", "echo"], check=False)
                if termios:
                    fd = sys.stdin.fileno()
                    attrs = termios.tcgetattr(fd)
                    attrs[3] |= termios.ECHO  # lflags: ensure echo
                    termios.tcsetattr(fd, termios.TCSANOW, attrs)
            except Exception:
                pass

    def _driver_ready() -> bool:
        drv = getattr(core, "driver", None)
        if drv is None:
            return False
        try:
            res = drv.health()
            return bool(res.get("ok", False)) if isinstance(res, dict) else True
        except Exception:
            return False

    def _wsl_to_windows_path(path: str) -> str:
        if path.startswith("/mnt/"):
            parts = path.split("/")
            if len(parts) >= 4:
                drive = parts[2]
                rest = "\\".join(parts[3:])
                return f"{drive.upper()}:\\{rest}"
        return path

    def _start_driver() -> bool:
        def _resolve_driver_host_port() -> tuple[str, int]:
            env_url = os.getenv("OS_DRIVER_URL") or ""
            if env_url:
                raw = env_url if "://" in env_url else f"http://{env_url}"
                parsed = urllib.parse.urlparse(raw)
                host = parsed.hostname or "127.0.0.1"
                try:
                    port = int(parsed.port or 5010)
                except Exception:
                    port = 5010
                return host, port
            env_host = os.getenv("OS_DRIVER_HOST")
            if env_host:
                try:
                    port = int(os.getenv("OS_DRIVER_PORT") or 5010)
                except Exception:
                    port = 5010
                return env_host, port
            return "127.0.0.1", 5010

        ps = shutil.which("powershell.exe") or shutil.which("powershell")
        if not ps:
            return False
        host, port = _resolve_driver_host_port()
        repo_posix = os.path.abspath(os.path.dirname(__file__) + "/..")
        repo_win = _wsl_to_windows_path(repo_posix).replace("/", "\\")
        vpy = os.path.join(repo_win, ".venv_os_driver", "Scripts", "python.exe")
        py_cmd = vpy if os.path.exists(vpy) else "python"
        cmd = [
            ps,
            "-NoProfile",
            "-ExecutionPolicy",
            "Bypass",
            "-Command",
            f"Start-Process -WindowStyle Hidden '{py_cmd}' -ArgumentList 'drivers\\os_driver.py --host {host} --port {port}'",
        ]
        try:
            subprocess.run(cmd, check=False, timeout=10)
            time.sleep(2)
            return _driver_ready()
        except Exception:
            return False

    def _execute_mission(
        intent_text: str,
        *,
        envelope_override: Optional[Any] = None,
        mission_mode: Optional[str] = None,
        ignore_waiting: bool = False,
    ) -> None:
        nonlocal jit_permit_pending, pending_answer_meta
        if not intent_text.strip():
            return
        if _ensure_core() is None:
            return
        # Interactive chat should not block on slow provider probes; use fast preflight by default.
        prev_chat_env = os.environ.get("AJAX_INTERACTIVE_CHAT")
        prev_fast_preflight = os.environ.get("AJAX_PREFLIGHT_FAST")
        prev_ignore_waiting = os.environ.get("AJAX_IGNORE_WAITING_MISSION")
        os.environ["AJAX_INTERACTIVE_CHAT"] = "1"
        if not prev_fast_preflight:
            os.environ["AJAX_PREFLIGHT_FAST"] = "1"
        if ignore_waiting:
            os.environ["AJAX_IGNORE_WAITING_MISSION"] = "1"
        preflight = None
        try:
            preflight = core.providers_preflight(requested_tier=os.getenv("AJAX_COST_MODE"))
        except Exception:
            preflight = None
        if isinstance(preflight, dict):
            requested_tier = preflight.get("requested_tier")
            chosen_tier = preflight.get("chosen_tier")
            chosen_provider = preflight.get("chosen_provider")
            fallback_chain = preflight.get("fallback_chain") or []
            print(
                f"requested_tier={requested_tier} chosen_tier={chosen_tier} chosen_provider={chosen_provider}"
            )
            if fallback_chain:
                print(f"fallback_chain={','.join(str(x) for x in fallback_chain if x)}")
            if chosen_tier and chosen_tier != requested_tier:
                os.environ["AJAX_COST_MODE"] = str(chosen_tier)
            os.environ["AJAX_PROVIDERS_PREFLIGHT_DONE"] = "1"
        if (os.getenv("AJAX_CHAT_EXEC_DRY_RUN") or "").strip().lower() in {
            "1",
            "true",
            "yes",
            "on",
        }:
            receipt_path = _write_exec_receipt(
                root_dir,
                {
                    "schema": "ajax.exec_receipt.v1",
                    "ts": time.time(),
                    "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                    "verify_ok": False,
                    "error": "dry_run",
                    "intent": intent_text,
                    "dry_run": True,
                },
            )
            if receipt_path:
                try:
                    rel = os.path.relpath(receipt_path, root_dir) if root_dir else str(receipt_path)
                except Exception:
                    rel = str(receipt_path)
                print(f"Resumen: dry_run receipt={rel}")
                return
        if not _driver_ready():
            print("Driver no disponible, intentando arrancarlo...")
            if not _start_driver():
                msg = "❌ Driver de acciones no disponible (127.0.0.1:5010). Reintenta tras arrancarlo."
                print(msg)
                if voice:
                    try:
                        voice.speak(msg)
                    except Exception:
                        pass
                receipt_path = _write_exec_receipt(
                    root_dir,
                    {
                        "schema": "ajax.exec_receipt.v1",
                        "ts": time.time(),
                        "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                        "verify_ok": False,
                        "error": "driver_unavailable",
                        "intent": intent_text,
                    },
                )
                if receipt_path:
                    try:
                        rel = (
                            os.path.relpath(receipt_path, root_dir)
                            if root_dir
                            else str(receipt_path)
                        )
                    except Exception:
                        rel = str(receipt_path)
                    print(f"Resumen: driver_unavailable receipt={rel}")
                return
        answer_meta = pending_answer_meta
        pending_answer_meta = None
        try:
            if mission_mode:
                mode_arg = str(mission_mode).strip().lower()
            else:
                mode_arg = "auto"
            result = core.do(
                intent_text,
                mode=mode_arg,
                envelope_override=envelope_override,
                ignore_waiting=ignore_waiting,
            )
        finally:
            if prev_chat_env is None:
                os.environ.pop("AJAX_INTERACTIVE_CHAT", None)
            else:
                os.environ["AJAX_INTERACTIVE_CHAT"] = prev_chat_env
            if prev_fast_preflight is None:
                os.environ.pop("AJAX_PREFLIGHT_FAST", None)
            else:
                os.environ["AJAX_PREFLIGHT_FAST"] = prev_fast_preflight
            if prev_ignore_waiting is None:
                os.environ.pop("AJAX_IGNORE_WAITING_MISSION", None)
            else:
                os.environ["AJAX_IGNORE_WAITING_MISSION"] = prev_ignore_waiting
        if jit_permit_pending:
            try:
                payload = dict(jit_permit_pending)
                payload["mission_id"] = getattr(getattr(core, "state", None), "mission_id", None)
                _write_jit_permit_receipt(root_dir, payload)
            except Exception:
                pass
            jit_permit_pending = None
        missing_players = None
        slots_missing = None
        slots_missing_count = None
        degraded = None
        degraded_reason = None
        optional_missing_players = None
        try:
            det = getattr(result, "detail", None)
            if isinstance(det, dict):
                mp = det.get("missing_players")
                if isinstance(mp, list):
                    missing_players = mp
                sm = det.get("slots_missing")
                if isinstance(sm, list):
                    slots_missing = sm
                smc = det.get("slots_missing_count")
                if isinstance(smc, (int, float)):
                    slots_missing_count = int(smc)
                if det.get("degraded") is not None:
                    degraded = bool(det.get("degraded"))
                dr = det.get("degraded_reason")
                if isinstance(dr, str) and dr.strip():
                    degraded_reason = dr.strip()
                omp = det.get("optional_missing_players")
                if isinstance(omp, list):
                    optional_missing_players = omp
        except Exception:
            missing_players = None
            slots_missing = None
            slots_missing_count = None
            degraded = None
            degraded_reason = None
            optional_missing_players = None
        exec_payload = {
            "schema": "ajax.exec_receipt.v1",
            "ts": time.time(),
            "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "verify_ok": bool(getattr(result, "success", False)),
            "error": getattr(result, "error", None),
            "path": getattr(result, "path", None),
            "intent": intent_text,
            "mission_id": getattr(getattr(core, "state", None), "mission_id", None),
            "missing_players": missing_players,
            "slots_missing": slots_missing,
            "slots_missing_count": slots_missing_count,
            "optional_missing_players": optional_missing_players,
            "degraded": degraded,
            "degraded_reason": degraded_reason,
        }
        if isinstance(answer_meta, dict):
            exec_payload.update(answer_meta)
        exec_receipt_path = _write_exec_receipt(
            root_dir,
            exec_payload,
        )
        try:
            _print_council_starting_xi_lines(root_dir)
        except Exception:
            pass
        try:
            _print_council_invocation_line(result, getattr(core, "state", None))
        except Exception:
            pass
        lines, voice_msg = _render_action_result(result, core.config.root_dir)
        for msg_line in lines:
            print(msg_line)
        try:
            ok = bool(getattr(result, "success", False))
            status = "OK" if ok else "FAIL"
            rel = None
            if exec_receipt_path:
                try:
                    rel = (
                        os.path.relpath(exec_receipt_path, root_dir)
                        if root_dir
                        else str(exec_receipt_path)
                    )
                except Exception:
                    rel = str(exec_receipt_path)
            if rel:
                print(f"Resumen: {status} receipt={rel}")
            else:
                print(f"Resumen: {status}")
        except Exception:
            pass
        if voice and voice_msg:
            try:
                voice.speak(voice_msg)
            except Exception:
                pass

    def _print_switchboard_help() -> None:
        print(
            "Switchboard: :mission | :chat | :back | :park | :resume [id] | :missions | :retry | :open_incident | :close_manual_done"
        )

    def _handle_switchboard_command(cmd: str, arg: str) -> bool:
        nonlocal session_mode, pending_answer_meta, chat_focus
        cmd = (cmd or "").strip().lower()
        arg = (arg or "").strip()
        if cmd in {"", "help", "h"}:
            _print_switchboard_help()
            return True
        if cmd in {"chat", "back"}:
            session_mode = "chat"
            chat_focus = "chat"
            print("Modo CHAT activado.")
            return True
        if cmd in {"mission", "resume"}:
            waiting_payload = _load_waiting_payload(root_dir)
            if not waiting_payload:
                if arg:
                    waiting_payload = _load_waiting_payload_from_mission(root_dir, arg)
            if not waiting_payload:
                print("No hay misión pendiente.")
                return True
            mission_id = waiting_payload.get("mission_id")
            if arg and str(arg) != str(mission_id):
                print(f"No coincide mission_id. Pendiente: {mission_id}")
                return True
            session_mode = "mission"
            chat_focus = _next_chat_focus(chat_focus, cmd, str(mission_id) if mission_id else None)
            _set_waiting_pause(root_dir, str(mission_id), paused=False)
            print("Modo MISSION activado.")
            for line in _render_waiting_prompt_from_payload(waiting_payload, root_dir):
                print(line)
            return True
        if cmd in {"list", "missions"}:
            if list_waiting_missions is None:
                print("Listado no disponible.")
                return True
            rows = list_waiting_missions(root_dir, limit=10)
            if not rows:
                print("No hay misiones pendientes/parked.")
                return True
            print("Misiones (max 10):")
            for row in rows:
                mid = row.get("mission_id") or "desconocida"
                status = row.get("status") or "WAITING_FOR_USER"
                paused = " (parked)" if row.get("parked_by_user") else ""
                print(f"- {mid} ({status}){paused}")
            return True
        if cmd in {"park", "pause"}:
            waiting_payload = _load_waiting_payload(root_dir)
            if not waiting_payload:
                print("No hay misión pendiente para aparcar.")
                return True
            mission_id = waiting_payload.get("mission_id")
            _set_waiting_pause(root_dir, str(mission_id), paused=True)
            session_mode = "chat"
            chat_focus = "chat"
            print(f"Misión aparcada: {mission_id}")
            return True
        if cmd in {
            "open_incident",
            "close_manual_done",
            "close_manual",
            "status",
            "answer",
            "retry",
        }:
            waiting_payload = _load_waiting_payload(root_dir)
            if not waiting_payload:
                print("No hay misión pendiente.")
                return True
            if _ensure_chat_lite() is None:
                return True
            pending_answer_meta = {}
            if cmd == "answer":
                if not arg:
                    print("Uso: :answer <texto>")
                    return True
                return _handle_waiting_input(
                    root_dir,
                    chat_core,
                    f"[answer] {arg}",
                    execute_mission=_execute_mission,
                    answer_meta=pending_answer_meta,
                )
            if cmd == "retry":
                return _execute_fresh_retry(
                    root_dir,
                    chat_core,
                    waiting_payload,
                    execute_mission=_execute_mission,
                    answer_meta=pending_answer_meta,
                )
            return _handle_waiting_input(
                root_dir,
                chat_core,
                f"[{cmd}]",
                execute_mission=_execute_mission,
                answer_meta=pending_answer_meta,
            )
        print(f"Comando desconocido: :{cmd}. Usa :help")
        return True

    _tty_sane()

    def _count_pending_missions() -> int:
        if list_waiting_missions is None:
            return 1
        try:
            rows = list_waiting_missions(root_dir, limit=10)
            return len(rows or [])
        except Exception:
            return 1

    prompt = "CHAT > "
    waiting_payload = _load_waiting_payload(root_dir)
    if waiting_payload:
        mission_id = waiting_payload.get("mission_id") or "desconocida"
        status = waiting_payload.get("status") or "WAITING_FOR_USER"
        pending_count = _count_pending_missions()
        count = pending_count or 1
        mission_word = "misión" if count == 1 else "misiones"
        print(
            f"Hay {count} {mission_word} en cola ({mission_id}, {status}). Usa :missions para listar, :mission para entrar, :park para aparcar."
        )
        _write_chat_receipt(
            root_dir,
            {
                "schema": "ajax.chat_event.v1",
                "ts": time.time(),
                "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "event": "chat_start_pending",
                "mission_id": waiting_payload.get("mission_id"),
                "status": waiting_payload.get("status"),
                "session_mode": session_mode,
                "chat_focus": chat_focus,
                "pending_missions_count": _count_pending_missions(),
                "mission_hijack_prevented": True,
            },
        )
    try:
        while True:
            try:
                _tty_sane()
                line = input(prompt)
            except EOFError:
                print("\nSaliendo.")
                break
            finally:
                # Asegurar eco tras cualquier lectura, incluso si input lanza
                _tty_sane()
            raw_line = line
            line = line.strip()
            cmd_colon, cmd_arg = _parse_colon_command(line)
            if cmd_colon is not None:
                handled = _handle_switchboard_command(cmd_colon, cmd_arg)
                if handled:
                    continue
            if not line:
                waiting_payload = _load_waiting_payload(root_dir)
                if _should_route_waiting_input(
                    line=raw_line, chat_focus=chat_focus, waiting_payload=waiting_payload
                ):
                    if _ensure_chat_lite() is None:
                        continue
                    pending_answer_meta = {}
                    if _handle_waiting_input(
                        root_dir,
                        chat_core,
                        raw_line,
                        execute_mission=_execute_mission,
                        answer_meta=pending_answer_meta,
                    ):
                        if pending_answer_meta:
                            pass
                        else:
                            pending_answer_meta = None
                        continue
                    pending_answer_meta = None
                continue
            if line.lower() in {"/exit", "exit", "quit"}:
                print("Hasta luego.")
                break
            if line.lower().startswith("/debug"):
                arg = line[len("/debug") :].strip().lower()
                if arg in {"on", "1", "true", "yes"}:
                    debug_enabled = True
                elif arg in {"off", "0", "false", "no"}:
                    debug_enabled = False
                else:
                    debug_enabled = not debug_enabled
                os.environ["AJAX_CHAT_DEBUG"] = "1" if debug_enabled else "0"
                print(f"Debug: {'ON' if debug_enabled else 'OFF'}")
                continue
            if line.startswith("/health"):
                if _ensure_core() is None:
                    continue
                report = core.health_check(strict=False)
                payload = report.to_dict() if hasattr(report, "to_dict") else report
                print(
                    f"Health: driver_ok={payload.get('driver_ok')} models={payload.get('models_count')} notes={payload.get('notes')}"
                )
                continue
            if line.startswith("/research"):
                if _ensure_core() is None:
                    continue
                topic = line[len("/research") :].strip()
                if not topic:
                    print("Uso: /research <tema>")
                    continue
                ctx = f"Invocado desde chat; health={getattr(core, 'health', None)}"
                try:
                    report_path = scout.investigate(topic=topic, context=ctx)
                    print(f"✅ Research listo: {report_path}")
                except Exception as exc:
                    print(f"❌ Research falló: {exc}")
                continue

            snap_key = line.strip().lower()
            if snap_key.startswith("[") and snap_key.endswith("]"):
                snap_key = snap_key[1:-1].strip().lower()
            if snap_key in {"snap", "snap+vision"}:
                if _ensure_core() is None:
                    continue
                payload, _mission_id, _job_id = _resolve_waiting_context(core.config.root_dir)
                status = str(payload.get("status") or "").upper() if payload else ""
                if status in {"WAITING_FOR_USER", "PAUSED_FOR_LAB"}:
                    _handle_snap_request(core.config.root_dir, mode=snap_key)
                else:
                    print(
                        "Snap disponible solo en WAITING_FOR_USER/PAUSED_FOR_LAB. Usa: ajaxctl desktop snap"
                    )
                continue

            waiting_payload = _load_waiting_payload(root_dir)
            if (
                waiting_payload
                and session_mode == "chat"
                and concierge is not None
                and chat_focus != "chat"
            ):
                state = _build_concierge_state(waiting_payload)
                if state is not None:
                    cue = concierge.interpret(line, state, mode="chat")
                    intent = str(cue.get("intent") or "")
                    if intent == "mission":
                        mission_id = waiting_payload.get("mission_id")
                        _set_waiting_pause(root_dir, str(mission_id), paused=False)
                        session_mode = "mission"
                        print("Modo MISSION activado.")
                        for msg_line in _render_waiting_prompt_from_payload(
                            waiting_payload, root_dir
                        ):
                            print(msg_line)
                        continue
                    if intent == "park":
                        mission_id = waiting_payload.get("mission_id")
                        _set_waiting_pause(root_dir, str(mission_id), paused=True)
                        session_mode = "chat"
                        print(f"Misión aparcada: {mission_id}")
                        continue
                    if intent in {"open_incident", "close_manual_done"}:
                        if _ensure_chat_lite() is None:
                            continue
                        pending_answer_meta = {}
                        if _handle_waiting_input(
                            root_dir,
                            chat_core,
                            f"[{intent}]",
                            execute_mission=_execute_mission,
                            answer_meta=pending_answer_meta,
                        ):
                            pending_answer_meta = None
                            continue
                    if intent == "concierge_message":
                        msg = cue.get("ui_message") or ""
                        if msg:
                            print(str(msg))
                        sugg = cue.get("ui_suggestions") or []
                        if sugg:
                            print("Opciones: " + " | ".join(str(s) for s in sugg))
                        continue
                    if intent == "mission_answer":
                        answer_text = cue.get("answer_text") or ""
                        if answer_text:
                            if _ensure_chat_lite() is None:
                                continue
                            pending_answer_meta = {}
                            if _handle_waiting_input(
                                root_dir,
                                chat_core,
                                f"[answer] {answer_text}",
                                execute_mission=_execute_mission,
                                answer_meta=pending_answer_meta,
                            ):
                                pending_answer_meta = None
                                continue

            if _should_route_waiting_input(
                line=line, chat_focus=chat_focus, waiting_payload=waiting_payload
            ):
                if _ensure_chat_lite() is None:
                    continue
                pending_answer_meta = {}
                if _handle_waiting_input(
                    root_dir,
                    chat_core,
                    line,
                    execute_mission=_execute_mission,
                    answer_meta=pending_answer_meta,
                ):
                    if pending_answer_meta:
                        pass
                    else:
                        pending_answer_meta = None
                    continue
                pending_answer_meta = None

            # Fast chat path
            perf = {}
            chat_mode = "full_core"
            if chat_lite_enabled:
                if _ensure_chat_lite() is None:
                    continue
                chat_mode = "chat_lite"
                reply, perf = chat_core.chat_with_perf(line)
            else:
                if _ensure_core() is None:
                    continue
                reply, perf = core.chat_with_perf(line)
            action_required = bool(perf.get("action_required") or "[ACTION_REQUIRED]" in reply)
            intent = None
            try:
                intent = getattr(chat_core, "last_action_intent", None) if chat_core else None
                intent = intent or getattr(core, "last_action_intent", None)
            except Exception:
                intent = None
            intent = intent or line
            risk_level = _infer_risk_level_from_intent(intent)
            rail = _resolve_rail()
            user_id = None
            try:
                user_id = getattr(getattr(chat_core, "config", None), "user_id", None) or getattr(
                    getattr(core, "config", None),
                    "user_id",
                    None,
                )
            except Exception:
                user_id = None
            user_id = (
                user_id or os.getenv("AJAX_USER_ID") or os.getenv("AJAX_DEFAULT_USER") or "primary"
            )
            jit_decision = None
            if evaluate_jit_permit is not None:
                try:
                    jit_decision = evaluate_jit_permit(
                        action_required=action_required,
                        user_id=user_id,
                        rail=rail,
                        risk_level=risk_level,
                        interactive=_is_interactive(),
                    )
                except Exception:
                    jit_decision = None
            jit_confirmation_required = bool(jit_decision and jit_decision.requires_confirmation)
            if action_required and jit_decision and jit_decision.requires_confirmation:
                prompt = "Confirmación requerida (riesgo alto). ¿Ejecutar? [sí/no]: "
                try:
                    answer = input(prompt)
                except EOFError:
                    answer = ""
                if confirm_jit_permit is not None:
                    try:
                        jit_decision = confirm_jit_permit(jit_decision, _is_yes_response(answer))
                    except Exception:
                        jit_decision = None
                else:
                    if not _is_yes_response(answer):
                        jit_decision = None
            if jit_confirmation_required and not (jit_decision and jit_decision.auto_permit):
                print("Cancelado.")
                continue
            suppress_action_required = bool(
                jit_decision
                and action_required
                and bool(getattr(jit_decision, "suppress_action_required", False))
            )
            if action_required and jit_decision and jit_decision.auto_permit:
                perm_ok = False
                granted = False
                if read_human_permission_status is not None:
                    try:
                        perm = read_human_permission_status(root_dir)
                        perm_ok = bool(perm.get("ok"))
                    except Exception:
                        perm_ok = False
                if not perm_ok and grant_human_permission is not None:
                    try:
                        grant = grant_human_permission(root_dir, 120)
                        perm_ok = bool(grant.get("ok"))
                        granted = perm_ok
                    except Exception:
                        perm_ok = False
                if perm_ok and granted:
                    jit_permit_pending = {
                        "schema": "ajax.permit_receipt.v1",
                        "ts": time.time(),
                        "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                        "source": "implicit_jit",
                        "seconds": 120,
                        "intent": intent,
                        "risk_score": _risk_score_from_level(risk_level),
                        "rail": rail,
                        "mission_id": None,
                    }
            if not (suppress_action_required and reply.strip() == "[ACTION_REQUIRED]"):
                print(reply)
            print(f"Chat mode: {chat_mode}")
            timing_line = "Timing:"

            def _fmt_ms(val: Any) -> str:
                if val is None:
                    return "n/a"
                try:
                    return f"{float(val):.2f}ms"
                except Exception:
                    return "n/a"

            timing_line = (
                f"Timing: init_chat_lite={_fmt_ms(t_init_chat_lite)} "
                f"init_full_core={_fmt_ms(t_init_full_core)} "
                f"t_leann={_fmt_ms(perf.get('t_leann'))} "
                f"t_llm={_fmt_ms(perf.get('t_llm'))}"
            )
            print(timing_line)
            if debug_enabled:
                try:
                    gate = perf.get("intent_gate") if isinstance(perf, dict) else None
                    if isinstance(gate, dict):
                        print("IntentGate:", json.dumps(gate, ensure_ascii=False))
                except Exception:
                    pass
                try:
                    print(
                        f"LEANN: mode={perf.get('leann_mode')} reason={perf.get('leann_reason')} snippets={perf.get('snippets_count')}"
                    )
                except Exception:
                    pass
            receipt_payload = {
                "schema": "ajax.chat_perf.v1",
                "ts": time.time(),
                "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "mode": chat_mode,
                "action_required": bool(
                    perf.get("action_required") or "[ACTION_REQUIRED]" in reply
                ),
                "intent_gate": perf.get("intent_gate")
                if isinstance(perf.get("intent_gate"), dict)
                else None,
                "t_init_chat_lite_ms": t_init_chat_lite,
                "t_init_full_core_ms": t_init_full_core,
                "t_leann_ms": perf.get("t_leann"),
                "t_llm_ms": perf.get("t_llm"),
                "chat_focus": chat_focus,
                "pending_missions_count": _count_pending_missions() if waiting_payload else 0,
                "mission_hijack_prevented": bool(waiting_payload and chat_focus == "chat"),
            }
            _write_chat_perf_receipt(root_dir, receipt_payload)
            if voice:
                try:
                    voice.speak(reply)
                except Exception:
                    pass
            if "[ACTION_REQUIRED]" in reply:
                if chat_mode == "chat_lite":
                    print("transition: chat_lite -> full_core due_to=commit")
                prev_skip_driver = os.environ.get("AJAX_SKIP_DRIVER_AUTOSTART")
                prev_skip_health = os.environ.get("AJAX_SKIP_HEALTH_ON_BOOT")
                prev_skip_caps = os.environ.get("AJAX_SKIP_CAPABILITIES_DISCOVERY")
                if chat_mode == "chat_lite":
                    os.environ["AJAX_SKIP_DRIVER_AUTOSTART"] = "1"
                    os.environ["AJAX_SKIP_HEALTH_ON_BOOT"] = "1"
                    os.environ["AJAX_SKIP_CAPABILITIES_DISCOVERY"] = "1"
                if _ensure_core() is None:
                    if prev_skip_driver is None:
                        os.environ.pop("AJAX_SKIP_DRIVER_AUTOSTART", None)
                    else:
                        os.environ["AJAX_SKIP_DRIVER_AUTOSTART"] = prev_skip_driver
                    if prev_skip_health is None:
                        os.environ.pop("AJAX_SKIP_HEALTH_ON_BOOT", None)
                    else:
                        os.environ["AJAX_SKIP_HEALTH_ON_BOOT"] = prev_skip_health
                    if prev_skip_caps is None:
                        os.environ.pop("AJAX_SKIP_CAPABILITIES_DISCOVERY", None)
                    else:
                        os.environ["AJAX_SKIP_CAPABILITIES_DISCOVERY"] = prev_skip_caps
                    continue
                if prev_skip_driver is None:
                    os.environ.pop("AJAX_SKIP_DRIVER_AUTOSTART", None)
                else:
                    os.environ["AJAX_SKIP_DRIVER_AUTOSTART"] = prev_skip_driver
                if prev_skip_health is None:
                    os.environ.pop("AJAX_SKIP_HEALTH_ON_BOOT", None)
                else:
                    os.environ["AJAX_SKIP_HEALTH_ON_BOOT"] = prev_skip_health
                if prev_skip_caps is None:
                    os.environ.pop("AJAX_SKIP_CAPABILITIES_DISCOVERY", None)
                else:
                    os.environ["AJAX_SKIP_CAPABILITIES_DISCOVERY"] = prev_skip_caps
                if t_init_full_core is not None:
                    print(f"init_full_core={t_init_full_core}ms")
                print("Entendido, iniciando maniobra...")
                intent = getattr(chat_core, "last_action_intent", None) if chat_core else None
                intent = intent or getattr(core, "last_action_intent", None) or line
                ignore_waiting = False
                if chat_mode == "chat_lite":
                    intent_gate = perf.get("intent_gate") if isinstance(perf, dict) else None
                    waiting_payload = _load_waiting_payload(root_dir)
                    if _should_ignore_waiting_for_direct_command(
                        intent_gate, chat_focus, waiting_payload
                    ):
                        ignore_waiting = True
                        if waiting_payload:
                            mission_id = waiting_payload.get("mission_id")
                            status = waiting_payload.get("status") or "WAITING_FOR_USER"
                            if mission_id:
                                _set_waiting_pause(
                                    root_dir,
                                    str(mission_id),
                                    paused=True,
                                    reason="commit_confirmed",
                                )
                            print(
                                f"He aparcado automáticamente la misión {mission_id or 'desconocida'} ({status}) y he creado una nueva misión para la intención confirmada."
                            )
                            print("Usa :missions / :resume / :mission para volver.")
                _execute_mission(intent, ignore_waiting=ignore_waiting)
    finally:
        _tty_sane()
    return 0


def cmd_research(args: argparse.Namespace) -> int:
    topic = " ".join(args.topic).strip()
    if not topic:
        print("No research topic provided.", file=sys.stderr)
        return 1
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    context = args.context or f"Invocado desde ajaxctl; health={getattr(core, 'health', None)}"
    root = core.config.root_dir if hasattr(core, "config") else None
    scout = Scout(ScoutConfig.default(root=root))
    report_path = scout.investigate(topic=topic, context=context)
    payload = {
        "success": True,
        "topic": topic,
        "report_path": str(report_path),
    }
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_inspect(args: argparse.Namespace) -> int:
    if Inspector is None:
        print("Inspector no disponible (agency.inspector no importable).", file=sys.stderr)
        return 2
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    root = getattr(core, "config", None).root_dir if hasattr(core, "config") else Path(".")
    history_dir = Path(root) / "artifacts" / "history"
    driver_status = core.driver_breaker_state() if hasattr(core, "driver_breaker_state") else {}
    driver_policy = getattr(core, "security_policy", {})
    inspector = Inspector(
        history_dir,
        driver_status=driver_status,
        driver_policy=driver_policy,
        include_driver=bool(getattr(args, "drivers", False)),
    )
    summary = inspector.summarize_recent_failures(limit=args.last)
    print(json.dumps(summary, indent=2, ensure_ascii=False))
    return 0


def cmd_tools_show(args: argparse.Namespace) -> int:
    if load_inventory is None:
        print("Inventario no disponible (agency.tool_inventory no importable).", file=sys.stderr)
        return 3
    inv = load_inventory()
    payload = []
    for spec in inv:
        try:
            payload.append(spec.to_dict() if hasattr(spec, "to_dict") else spec)
        except Exception:
            payload.append(str(spec))
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_tools_status(args: argparse.Namespace) -> int:
    if load_inventory is None or get_tool_status is None:
        print("Snapshot no disponible (imports de tool_inventory fallaron).", file=sys.stderr)
        return 3
    inv = load_inventory()
    heartbeat = load_heartbeat_snapshot() if load_heartbeat_snapshot else {}
    snapshot = get_tool_status(inv, heartbeat)
    tools_payload = {}
    for key, st in snapshot.items():
        try:
            tools_payload[key] = st.to_dict() if hasattr(st, "to_dict") else st
        except Exception:
            tools_payload[key] = str(st)
    payload = {"heartbeat": heartbeat, "tools": tools_payload}
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_tools_sync(args: argparse.Namespace) -> int:
    print("TODO: tools sync aún no implementado (plantilla offline).")
    return 0


def cmd_tools_notes(args: argparse.Namespace) -> int:
    if load_tool_use_notes is None:
        print("Notas no disponibles (imports fallidos).", file=sys.stderr)
        return 3
    notes = load_tool_use_notes()
    print(json.dumps(notes, indent=2, ensure_ascii=False))
    return 0


def _check_ajax_history_notice() -> None:
    root = Path(__file__).resolve().parents[1]
    source = root / "ingest_ajax_history.json"
    summary = root / "artifacts" / "ingest" / "ajax_history_summary.json"
    log_path = root / "logs" / "ajax_history_notice.log"
    if not source.exists():
        return
    source_mtime = source.stat().st_mtime
    summary_mtime = summary.stat().st_mtime if summary.exists() else 0
    if source_mtime > summary_mtime:
        msg = (
            "Existe ingest_ajax_history.json más reciente que la última ingesta. "
            "Ejecuta 'bin/ajaxctl leann-ingest-history' para actualizar LEANN."
        )
        log_path.parent.mkdir(parents=True, exist_ok=True)
        with log_path.open("a", encoding="utf-8") as fh:
            fh.write(msg + "\n")
        print(msg, file=sys.stderr)


def cmd_leann_ingest_history(args: argparse.Namespace) -> int:
    root = Path(__file__).resolve().parents[1]
    config_path = args.config or root / "configs" / "ingest_ajax_history.json"
    source = root / "ingest_ajax_history.json"
    summary_path = root / "artifacts" / "ingest" / "ajax_history_summary.json"

    if not source.exists():
        print(
            f"❌ No se encontró {source}. Copia el export a la raíz y reintenta.", file=sys.stderr
        )
        return 2
    cmd = [
        "python3",
        str(root / "bin" / "ingest_ajax_history.py"),
        "--config",
        str(config_path),
    ]
    print(f"▶️ Ejecutando ingesta: {' '.join(cmd)}")
    proc = subprocess.run(cmd, cwd=root, text=True)
    if proc.returncode != 0:
        print(f"❌ Ingesta falló (rc={proc.returncode}).", file=sys.stderr)
        return proc.returncode
    if summary_path.exists():
        try:
            summary = json.loads(summary_path.read_text(encoding="utf-8"))
            print("✅ Ingesta completada. Resumen:")
            print(json.dumps(summary, ensure_ascii=False, indent=2))
            return 0
        except Exception:
            pass
    print("⚠️ Ingesta terminada sin resumen legible; revisa logs/artifacts.", file=sys.stderr)
    return 0


def cmd_voice_session(args: argparse.Namespace) -> int:
    from agency.voice.voice_session import run_voice_session

    return run_voice_session()


def cmd_marcapasos_start(args: argparse.Namespace) -> int:
    cmd = [
        sys.executable,
        str((ROOT / "agency" / "heartkeeper.py")),
        "--interval",
        str(args.interval),
        "--escalate-after",
        str(args.escalate_after),
        "--daemon",
    ]
    if args.max_cycles:
        cmd.extend(["--max-cycles", str(args.max_cycles)])
    proc = subprocess.run(cmd, cwd=ROOT, text=True)
    rc = proc.returncode
    # Tras arrancar, genera reporte diario para dejar el artefacto fresco
    try:
        from agency.reporting.daily_report import build_daily_report

        report = build_daily_report()
        out_path = ROOT / "artifacts" / "reports" / "daily_report.md"
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(report, encoding="utf-8")
    except Exception:
        pass
    return rc


def cmd_marcapasos_stop(args: argparse.Namespace) -> int:
    pidfile = ROOT / "artifacts" / "health" / "heartkeeper.pid"
    if not pidfile.exists():
        print("No hay pidfile de heartkeeper; nada que parar.")
        return 0
    try:
        pid = int(pidfile.read_text(encoding="utf-8").strip())
        os.kill(pid, 15)
        print(f"Enviado SIGTERM a heartkeeper (pid={pid}).")
    except Exception as exc:
        print(f"No se pudo parar heartkeeper: {exc}")
        return 1
    finally:
        try:
            pidfile.unlink()
        except Exception:
            pass
    return 0


def cmd_experiment_run(args: argparse.Namespace) -> int:
    try:
        from agency.experiment_runner import ScientificMethodRunner, ExperimentRunError
    except Exception as exc:
        print(f"Experiment runner no disponible: {exc}", file=sys.stderr)
        return 3
    runner = ScientificMethodRunner(ROOT)
    try:
        summary = runner.run(
            Path(args.envelope),
            promote_task=args.promote_task,
            allow_promotion=args.allow_promotion,
        )
    except ExperimentRunError as exc:
        print(f"Experiment run failed: {exc}", file=sys.stderr)
        return 2
    payload = {
        "run_id": summary.run_id,
        "run_dir": str(summary.run_dir),
        "operational_status": summary.operational_status,
        "gate_decision": summary.gate_decision,
        "publication_record": str(summary.published_record) if summary.published_record else None,
        "capability_gap": str(summary.capability_gap) if summary.capability_gap else None,
    }
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0 if summary.operational_status == "PASS" else 2


def cmd_permit(args: argparse.Namespace) -> int:
    try:
        from agency.human_permission import (
            grant_human_permission,
            revoke_human_permission,
            read_human_permission_status,
            human_permission_gate_enabled,
        )
    except Exception as exc:
        print(f"HUMAN_PERMISSION no disponible: {exc}", file=sys.stderr)
        return 3
    if not human_permission_gate_enabled():
        payload = read_human_permission_status(ROOT)
        payload["gate_enabled"] = False
        print(json.dumps(payload, indent=2, ensure_ascii=False))
        return 0
    if getattr(args, "revoke", False):
        payload = revoke_human_permission(ROOT)
        payload["gate_enabled"] = True
        print(json.dumps(payload, indent=2, ensure_ascii=False))
        return 0 if payload.get("ok") else 2
    if getattr(args, "status", False):
        payload = read_human_permission_status(ROOT)
        payload["gate_enabled"] = True
        print(json.dumps(payload, indent=2, ensure_ascii=False))
        return 0 if payload.get("ok") else 2
    ttl = int(getattr(args, "seconds", 120) or 120)
    payload = grant_human_permission(ROOT, ttl)
    payload["gate_enabled"] = True
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0 if payload.get("ok") else 2


def cmd_gaps_triage(args: argparse.Namespace) -> int:
    try:
        from agency.gaps_triage import triage_gaps, TriageError
    except Exception as exc:
        print(f"Gaps triage no disponible: {exc}", file=sys.stderr)
        return 3
    try:
        payload, json_path, md_path = triage_gaps(
            ROOT,
            top_n=args.top,
            rail=args.rail,
        )
    except TriageError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    result = {
        "ok": True,
        "triaged": payload.get("counts", {}).get("triaged", 0),
        "json_path": str(json_path),
        "md_path": str(md_path),
    }
    print(json.dumps(result, indent=2, ensure_ascii=False))
    return 0


def cmd_doctor_drivers(args: argparse.Namespace) -> int:
    ps_script = r"""
$ports = 5010,5012
$rows = @()
foreach ($port in $ports) {
  try {
    $conns = Get-NetTCPConnection -State Listen -LocalPort $port -ErrorAction SilentlyContinue
  } catch {
    $conns = @()
  }
  foreach ($conn in $conns) {
    $procId = $conn.OwningProcess
    $proc = $null
    if ($procId) {
      try { $proc = Get-CimInstance Win32_Process -Filter ("ProcessId={0}" -f $procId) } catch {}
    }
    $owner = $null
    if ($proc) {
      try {
        $ownerInfo = $proc.GetOwner()
        if ($ownerInfo.ReturnValue -eq 0) { $owner = "$($ownerInfo.Domain)\\$($ownerInfo.User)" }
      } catch {}
    }
    $rows += [pscustomobject]@{
      port = $port
      localAddress = $conn.LocalAddress
      pid = $procId
      name = if ($proc) { $proc.Name } else { $null }
      commandLine = if ($proc) { $proc.CommandLine } else { $null }
      owner = $owner
    }
  }
}
$rows | ConvertTo-Json -Depth 5
"""

    def _decode_ps_output(blob: bytes) -> str:
        if not blob:
            return ""
        if blob.startswith(b"\xff\xfe") or blob.startswith(b"\xfe\xff"):
            try:
                return blob.decode("utf-16")
            except UnicodeDecodeError:
                pass
        if b"\x00" in blob:
            try:
                return blob.decode("utf-16-le")
            except UnicodeDecodeError:
                pass
        for enc in ("utf-8", "cp1252", "latin-1"):
            try:
                return blob.decode(enc)
            except UnicodeDecodeError:
                continue
        return blob.decode("utf-8", errors="replace")

    try:
        proc = subprocess.run(
            ["powershell.exe", "-NoProfile", "-Command", ps_script],
            capture_output=True,
            check=False,
        )
    except FileNotFoundError as exc:
        print(f"PowerShell no disponible: {exc}", file=sys.stderr)
        return 3
    stderr = _decode_ps_output(proc.stderr).strip()
    if proc.returncode != 0:
        print(stderr or "Fallo ejecutando diagnóstico.", file=sys.stderr)
        return 2
    stdout = _decode_ps_output(proc.stdout).strip().lstrip("\ufeff")
    if not stdout:
        print("No hay listeners en 5010/5012.")
        return 0
    try:
        rows = json.loads(stdout)
    except json.JSONDecodeError as exc:
        print(f"Salida inválida del diagnóstico PowerShell: {exc}", file=sys.stderr)
        return 2
    if not rows:
        print("No hay listeners en 5010/5012.")
        return 0
    if isinstance(rows, dict):
        rows = [rows]
    rows = sorted(rows, key=lambda r: (r.get("port"), r.get("localAddress")))
    root_lower = str(ROOT).lower()
    print("Drivers activos (5010/5012):")
    for row in rows:
        port = row.get("port")
        pid = row.get("pid")
        addr = row.get("localAddress")
        name = row.get("name") or "-"
        owner = row.get("owner") or "-"
        cmdline = row.get("commandLine") or "-"
        repo_path = "-"
        if row.get("commandLine"):
            cmd_lower = row["commandLine"].lower()
            idx = cmd_lower.find(root_lower)
            if idx != -1:
                end = row["commandLine"].find(".py", idx)
                if end != -1:
                    repo_path = row["commandLine"][idx : end + 3]
                else:
                    repo_path = row["commandLine"][idx:]
        print(f"port={port} pid={pid} owner={owner}")
        print(f"  addr={addr} name={name}")
        print(f"  cmd={cmdline}")
        print(f"  repo_path={repo_path}")

    # Vendor integrity check
    print("\nVerificando integridad de binarios vendor...")
    try:
        from bin.verify_vendor_hashes import verify as verify_vendor

        if not verify_vendor():
            print("\n[GAP] GAP:vendor_binary_tampered - Uno o más binarios han sido modificados.")
            return 2
    except ImportError:
        print("\n[WARN] No se pudo cargar el verificador de hashes vendor.")

    return 0


def cmd_doctor_anchor(args: argparse.Namespace) -> int:
    try:
        from agency.anchor_preflight import run_anchor_preflight  # type: ignore
    except Exception as exc:
        print(f"Anchor doctor no disponible: {exc}", file=sys.stderr)
        return 3
    rail = str(getattr(args, "rail", None) or _resolve_rail() or "lab").strip().lower()
    try:
        payload = run_anchor_preflight(root_dir=ROOT, rail=rail, write_receipt=True)
    except Exception as exc:
        print(f"Fallo al ejecutar doctor anchor: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(payload, ensure_ascii=False, indent=2))
    return 0 if bool(payload.get("ok")) else 2


def cmd_doctor_provider_alias(args: argparse.Namespace) -> int:
    print("Alias detectado: `doctor provider` -> `doctor providers`.")
    return cmd_doctor_providers(args)


def _latest_file(paths: list[Path]) -> Optional[Path]:
    existing = [p for p in paths if p.exists()]
    if not existing:
        return None
    existing.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return existing[0]


def _latest_snapshot0_payload(root_dir: Path) -> Optional[Dict[str, Any]]:
    snap_dir = root_dir / "artifacts" / "missions" / "snapshots"
    latest = _latest_file(list(snap_dir.glob("*_snapshot0.json")))
    if latest is None:
        return None
    data = _read_json(latest)
    return data if isinstance(data, dict) else None


def _latest_undo_plan_path(root_dir: Path) -> Optional[str]:
    tx_dir = root_dir / "artifacts" / "missions" / "transactions"
    latest = _latest_file(list(tx_dir.glob("**/undo_attempt*.json")))
    if latest is None:
        return None
    return str(latest)


def _write_microfilm_report(root_dir: Path, payload: Dict[str, Any]) -> Path:
    report_dir = root_dir / "artifacts" / "reports"
    report_dir.mkdir(parents=True, exist_ok=True)
    report_path = report_dir / "microfilm_compliance.md"
    checks = payload.get("checks") if isinstance(payload.get("checks"), list) else []
    lines = [
        "# Microfilm Compliance v1",
        "",
        f"- generated_at: {payload.get('ts_utc')}",
        f"- rail: {payload.get('rail')}",
        f"- result: {'PASS' if payload.get('overall_ok') else 'FAIL'}",
        f"- actionable_hint: {payload.get('actionable_hint') or 'none'}",
        "",
        "## Checks",
        "",
        "| check | status | code | hint |",
        "|---|---|---|---|",
    ]
    for check in checks:
        if not isinstance(check, dict):
            continue
        status = "PASS" if check.get("ok") else "FAIL"
        lines.append(
            "| {name} | {status} | {code} | {hint} |".format(
                name=str(check.get("name") or "-"),
                status=status,
                code=str(check.get("code") or "-"),
                hint=str(check.get("actionable_hint") or "-").replace("|", "/"),
            )
        )
    lines.extend(["", "## Raw", "", "```json", json.dumps(payload, ensure_ascii=False, indent=2), "```", ""])
    report_path.write_text("\n".join(lines), encoding="utf-8")
    return report_path


def cmd_microfilm_check(args: argparse.Namespace) -> int:
    try:
        root_dir = _detect_repo_root(getattr(args, "root", None))
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 2

    rail = str(getattr(args, "rail", None) or _resolve_rail() or "lab").strip().lower()
    if rail not in {"lab", "prod"}:
        rail = "lab"
    try:
        from agency.anchor_preflight import run_anchor_preflight  # type: ignore
        from agency.health_ttl import provider_status_ttl  # type: ignore
        try:
            from agency.lab_dummy_driver import is_dummy_driver_simulated  # type: ignore
        except Exception:
            is_dummy_driver_simulated = None  # type: ignore
        from agency.microfilm_guard import (  # type: ignore
            enforce_ssc,
            enforce_verify_before_done,
            enforce_lab_prod_separation,
            enforce_evidence_tiers,
            enforce_undo_for_reversible,
        )
    except Exception as exc:
        print(f"Microfilm guard unavailable: {exc}", file=sys.stderr)
        return 3

    ts_utc = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    checks: list[Dict[str, Any]] = []

    anchor_payload: Dict[str, Any]
    try:
        anchor_payload = run_anchor_preflight(root_dir=root_dir, rail=rail, write_receipt=True)
    except Exception as exc:
        anchor_payload = {
            "ok": False,
            "status": "BLOCKED",
            "code": "anchor_preflight_exception",
            "reason": str(exc)[:200],
        }
    checks.append(
        {
            "name": "doctor_anchor",
            "ok": bool(anchor_payload.get("ok")),
            "code": "ANCHOR_OK" if bool(anchor_payload.get("ok")) else "BLOCKED_RAIL_MISMATCH",
            "actionable_hint": (
                ""
                if bool(anchor_payload.get("ok"))
                else (
                    anchor_payload.get("reason")
                    or "Run `python bin/ajaxctl doctor anchor --rail <lab|prod>` and fix mismatches."
                )
            ),
            "receipt_path": anchor_payload.get("receipt_path"),
            "detail": anchor_payload,
        }
    )

    try:
        ttl_seconds = int(os.getenv("AJAX_HEALTH_TTL_SEC") or 900)
    except Exception:
        ttl_seconds = 900
    freshness = provider_status_ttl(root_dir, ttl_seconds=ttl_seconds)
    checks.append(
        {
            "name": "doctor_health_ttl",
            "ok": not bool(freshness.get("stale")),
            "code": "HEALTH_TTL_OK"
            if not bool(freshness.get("stale"))
            else "BLOCKED_HEALTH_STALE",
            "actionable_hint": (
                "Run `python bin/ajaxctl doctor providers` to refresh providers status."
                if bool(freshness.get("stale"))
                else ""
            ),
            "detail": freshness,
        }
    )

    snapshot0 = _latest_snapshot0_payload(root_dir)
    undo_path = _latest_undo_plan_path(root_dir)
    actuation_context = bool(isinstance(snapshot0, dict) and snapshot0) or bool(undo_path)

    ssc_gate = enforce_ssc({"actuation": actuation_context, "snapshot0": snapshot0})
    if not actuation_context and bool(ssc_gate.get("ok")):
        ssc_gate["code"] = "SSC_NOT_APPLICABLE"
        ssc_gate["actionable_hint"] = ""
    checks.append({"name": "ssc", **ssc_gate})

    anchor_mismatches: list[dict[str, str]] = []
    for bucket in ("mismatches", "warnings"):
        raw = anchor_payload.get(bucket)
        if not isinstance(raw, list):
            continue
        for item in raw:
            if not isinstance(item, dict):
                continue
            code = str(item.get("code") or "").strip()
            if code:
                anchor_mismatches.append({"code": code})

    display_target = (
        str(os.getenv("AJAX_DISPLAY_TARGET") or "").strip().lower()
        or ("dummy" if rail == "lab" else "primary")
    )
    observed = anchor_payload.get("observed") if isinstance(anchor_payload, dict) else {}
    if rail == "lab" and isinstance(observed, dict) and bool(observed.get("display_target_is_dummy")):
        display_target = "dummy"
    separation_gate = enforce_lab_prod_separation(
        {
            "rail": rail,
            "display_target": display_target,
            "human_active": _read_human_active_flag(root_dir),
            "require_display_target": True,
            "anchor_mismatches": anchor_mismatches,
        }
    )
    checks.append({"name": "lab_prod_separation", **separation_gate})

    driver_simulated = False
    if is_dummy_driver_simulated is not None:
        try:
            driver_simulated = bool(
                is_dummy_driver_simulated(
                    root_dir,
                    port=5012 if rail == "lab" else 5010,
                    host="127.0.0.1",
                )
            )
        except Exception:
            driver_simulated = False

    evidence = enforce_evidence_tiers(
        {
            "driver_online": bool(anchor_payload.get("ok")),
            "driver_simulated": driver_simulated,
            "verification_mode": "real",
        },
        {
            "ok": bool(anchor_payload.get("ok")),
            "verification_mode": "real",
            "driver_simulated": driver_simulated,
        },
    )
    checks.append(
        {
            "name": "evidence_tier",
            "ok": bool(evidence.get("ok")),
            "code": "EVIDENCE_OK" if bool(evidence.get("ok")) else "BLOCKED_EVIDENCE_MISSING",
            "actionable_hint": evidence.get("actionable_hint"),
            "detail": evidence,
        }
    )

    if actuation_context:
        verify_gate = enforce_verify_before_done({"status": "DONE"}, evidence)
    else:
        verify_gate = {
            "ok": True,
            "status": "READY",
            "code": "VERIFY_NOT_APPLICABLE",
            "actionable_hint": "",
        }
    checks.append({"name": "verify_before_done", **verify_gate})

    if actuation_context:
        undo_gate = enforce_undo_for_reversible(
            {
                "steps": [{"action": "app.launch"}],
                "metadata": {
                    "has_reversible_actions": True,
                    "tx_paths": {"undo_plan_path": undo_path},
                },
            }
        )
    else:
        undo_gate = {
            "ok": True,
            "status": "READY",
            "code": "UNDO_NOT_APPLICABLE",
            "actionable_hint": "",
        }
    checks.append({"name": "undo_guard", **undo_gate})

    overall_ok = all(bool(c.get("ok")) for c in checks)
    actionable_hint = next(
        (
            str(c.get("actionable_hint") or "").strip()
            for c in checks
            if not bool(c.get("ok")) and str(c.get("actionable_hint") or "").strip()
        ),
        "No action required.",
    )

    payload = {
        "schema": "ajax.microfilm_compliance.v1",
        "ts_utc": ts_utc,
        "rail": rail,
        "overall_ok": overall_ok,
        "actionable_hint": actionable_hint,
        "checks": checks,
    }

    report_path = _write_microfilm_report(root_dir, payload)
    receipt_dir = root_dir / "artifacts" / "receipts"
    receipt_dir.mkdir(parents=True, exist_ok=True)
    receipt_path = receipt_dir / f"microfilm_check_{time.strftime('%Y%m%dT%H%M%SZ', time.gmtime())}.json"
    receipt_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")

    print(f"Microfilm Compliance v1: {'PASS' if overall_ok else 'FAIL'}")
    print(f"actionable_hint: {actionable_hint}")
    print(f"report: {report_path}")
    print(f"receipt: {receipt_path}")
    return 0 if overall_ok else 2


def cmd_audit(args: argparse.Namespace) -> int:
    try:
        from agency.audits.runner import list_registered_audits, run_named_audit  # type: ignore
    except Exception as exc:
        print(f"Audit runner no disponible: {exc}", file=sys.stderr)
        return 3
    audit_name = str(getattr(args, "audit_name", "") or "").strip().lower()
    try:
        registry = list_registered_audits()
    except Exception:
        registry = {}
    if not audit_name:
        print("Debe indicar un audit (ej: tx).", file=sys.stderr)
        return 2
    if registry and audit_name not in registry:
        known = ", ".join(sorted(registry.keys()))
        print(f"Audit desconocido: {audit_name}. Disponibles: {known}", file=sys.stderr)
        return 2
    try:
        root_dir = _detect_repo_root(getattr(args, "root", None))
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    try:
        payload = run_named_audit(
            name=audit_name,
            root_dir=root_dir,
            run_id=getattr(args, "run_id", None),
            last=int(getattr(args, "last", 1) or 1),
        )
    except Exception as exc:
        print(f"Fallo en audit {audit_name}: {exc}", file=sys.stderr)
        return 2
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        summary = payload.get("summary") if isinstance(payload.get("summary"), dict) else {}
        print(
            f"audit {audit_name} "
            f"ok={bool(payload.get('ok'))} "
            f"critical={int(summary.get('critical') or 0)} "
            f"error={int(summary.get('error') or 0)} "
            f"warn={int(summary.get('warn') or 0)}"
        )
        artifact_path = payload.get("artifact_path")
        receipt_path = payload.get("receipt_path")
        if artifact_path:
            print(f"artifact={artifact_path}")
        if receipt_path:
            print(f"receipt={receipt_path}")
    return 0 if bool(payload.get("ok")) else 2


def cmd_soak_check(args: argparse.Namespace) -> int:
    rail = str(getattr(args, "rail", None) or _resolve_rail() or "lab").strip().lower()
    if rail not in {"lab", "prod"}:
        rail = "lab"
    try:
        window_min = int(getattr(args, "window_min", 60) or 60)
    except Exception:
        window_min = 60
    window_min = max(1, window_min)

    requested_root = getattr(args, "root", None)
    forced_reason = None
    try:
        root_dir = _detect_repo_root(requested_root)
    except RuntimeError as exc:
        root_dir = ROOT
        forced_reason = str(exc)

    try:
        from agency.soak_gate import run_soak_check  # type: ignore
    except Exception as exc:
        print(f"Soak gate unavailable: {exc}", file=sys.stderr)
        return 3

    payload = run_soak_check(
        root_dir=root_dir,
        rail=rail,
        window_min=window_min,
        forced_blocked_env_reason=forced_reason,
        requested_root=requested_root,
    )
    print(f"Soak Gate v1: {'PASS' if payload.get('ok') else 'FAIL'}")
    print(str(payload.get("summary_paragraph") or "No summary available."))
    print(f"receipt: {payload.get('receipt_path')}")
    print(f"report: {payload.get('report_path')}")
    return 0 if bool(payload.get("ok")) else 2


def _explain_starting_xi_providers(root_dir: Path, doctor_payload: dict, *, cost_mode: str) -> dict:
    try:
        from agency import starting_xi as starting_xi_mod  # type: ignore
        from agency.provider_breathing import _load_provider_configs  # type: ignore
        from agency import provider_ranker as provider_ranker_mod  # type: ignore
        from agency.provider_ledger import ProviderLedger  # type: ignore
    except Exception as exc:
        return {"ok": False, "error": f"imports_failed:{exc}"}

    provider_configs = _load_provider_configs(root_dir)
    providers_cfg = provider_configs.get("providers") if isinstance(provider_configs, dict) else {}
    if not isinstance(providers_cfg, dict):
        providers_cfg = {}

    rail_raw = os.getenv("AJAX_RAIL") or os.getenv("AJAX_ENV") or os.getenv("AJAX_MODE") or "lab"
    try:
        rail = starting_xi_mod._normalize_rail(rail_raw)
    except Exception:
        rail = str(rail_raw or "lab").strip().lower() or "lab"
    risk_level = "medium"
    try:
        risk_level = starting_xi_mod._normalize_risk_level(risk_level)
    except Exception:
        risk_level = str(risk_level or "medium").strip().lower() or "medium"

    try:
        sx = starting_xi_mod.build_starting_xi(
            root_dir=root_dir,
            provider_configs=provider_configs,
            rail=rail,
            risk_level=risk_level,
            cost_mode=cost_mode,
            run_breathing=False,
            run_inventory_sync=False,
        )
    except Exception as exc:
        return {"ok": False, "error": f"starting_xi_failed:{exc}"}

    include_local = bool(((sx.get("policy") or {}).get("include_local")))
    status_doc = starting_xi_mod._safe_read_json(
        root_dir / "artifacts" / "health" / "providers_status.json"
    )
    inv_doc, _inv_by_provider = starting_xi_mod._extract_inventory_maps(root_dir)

    ledger_ok = bool(((sx.get("preflight") or {}).get("ledger") or {}).get("ok"))
    ok_by_role: dict[str, set[str]] = {}
    if ledger_ok:
        ledger_path = (sx.get("inputs") or {}).get("provider_ledger_path") or (
            root_dir / "artifacts" / "provider_ledger" / "latest.json"
        )
        try:
            ledger_doc = starting_xi_mod._safe_read_json(Path(ledger_path))
            rows = ledger_doc.get("rows") if isinstance(ledger_doc, dict) else None
            rows = rows if isinstance(rows, list) else []
            ok_by_role = {
                "brain": set(ProviderLedger.ok_providers(rows, role="brain")),
                "council": set(ProviderLedger.ok_providers(rows, role="council")),
                "vision": set(ProviderLedger.ok_providers(rows, role="vision")),
            }
        except Exception:
            ok_by_role = {}

    def _invokable_provider(cfg: dict) -> bool:
        kind = str(cfg.get("kind") or "").strip().lower()
        return bool(kind and kind != "static")

    def _filter_pool(pool: list[str]) -> list[str]:
        out: list[str] = []
        for name in pool:
            cfg = providers_cfg.get(name)
            if not isinstance(cfg, dict):
                continue
            if cfg.get("disabled"):
                continue
            if not _invokable_provider(cfg):
                continue
            if not include_local and provider_ranker_mod._is_local_provider(cfg):
                continue
            out.append(name)
        return out

    brain_pool_raw = starting_xi_mod._providers_with_role(providers_cfg, "brain")
    council_pool_raw = starting_xi_mod._providers_with_role(providers_cfg, "council")
    vision_role_pool = starting_xi_mod._providers_with_role(providers_cfg, "vision")
    vision_fallback = starting_xi_mod._providers_with_vision_models(
        inv_doc
    ) | starting_xi_mod._providers_with_static_vision_hint(providers_cfg)
    vision_pool_raw = list(vision_role_pool)
    for item in sorted(vision_fallback):
        if item not in vision_pool_raw:
            vision_pool_raw.append(item)

    brain_pool = _filter_pool(brain_pool_raw)
    council_pool = _filter_pool(council_pool_raw)
    vision_pool = _filter_pool([p for p in vision_pool_raw if p in providers_cfg])

    if ledger_ok and ok_by_role:
        brain_pool = [p for p in brain_pool if p in ok_by_role.get("brain", set())]
        council_pool = [p for p in council_pool if p in ok_by_role.get("council", set())]
        vision_pool = [p for p in vision_pool if p in ok_by_role.get("vision", set())]

    eligible_by_role = {
        "brain": set(brain_pool),
        "council": set(council_pool),
        "vision": set(vision_pool),
    }

    included_roles: dict[str, set[str]] = {}

    def _mark_included(role_label: str, entry: Any) -> None:
        if not isinstance(entry, dict):
            return
        provider = entry.get("provider")
        if not isinstance(provider, str) or not provider.strip():
            return
        included_roles.setdefault(provider, set()).add(role_label)

    brain = sx.get("brain") if isinstance(sx.get("brain"), dict) else {}
    council = sx.get("council") if isinstance(sx.get("council"), dict) else {}
    vision = sx.get("vision") if isinstance(sx.get("vision"), dict) else {}

    _mark_included("brain", brain.get("primary"))
    for item in brain.get("bench") or []:
        _mark_included("brain", item)
    c1 = council.get("role1") if isinstance(council.get("role1"), dict) else {}
    c2 = council.get("role2") if isinstance(council.get("role2"), dict) else {}
    _mark_included("council.role1", c1.get("primary"))
    for item in c1.get("bench") or []:
        _mark_included("council.role1", item)
    _mark_included("council.role2", c2.get("primary"))
    for item in c2.get("bench") or []:
        _mark_included("council.role2", item)
    _mark_included("vision", vision.get("primary"))
    for item in vision.get("bench") or []:
        _mark_included("vision", item)

    def _auth_reason(cfg: dict, st: dict) -> Optional[str]:
        auth_state = str(st.get("auth_state") or "").upper()
        if auth_state not in {"MISSING", "EXPIRED"}:
            return None
        try:
            from agency.auth_manager import AuthManager  # type: ignore
        except Exception:
            return None
        try:
            if AuthManager.is_web_auth_required(cfg):
                return f"auth_{auth_state.lower()}"
        except Exception:
            return None
        return None

    def _role_exclusion_reason(provider: str, role: str) -> str:
        cfg = providers_cfg.get(provider)
        if not isinstance(cfg, dict):
            return "not_in_config"
        if cfg.get("disabled"):
            return "disabled_in_config"
        if not _invokable_provider(cfg):
            return "not_invokable"
        if not include_local and provider_ranker_mod._is_local_provider(cfg):
            return "local_provider_blocked"
        if role == "vision":
            if provider not in vision_pool_raw:
                return "vision_not_enabled"
        elif role == "brain":
            if provider not in brain_pool_raw:
                return "role_not_enabled"
        elif role == "council":
            if provider not in council_pool_raw:
                return "role_not_enabled"
        st = (
            (status_doc.get("providers") or {}).get(provider)
            if isinstance(status_doc, dict)
            else {}
        )
        st = st if isinstance(st, dict) else {}
        auth_reason = _auth_reason(cfg, st)
        if auth_reason:
            return auth_reason
        if ledger_ok and ok_by_role:
            allowed = ok_by_role.get(role, set())
            if allowed and provider not in allowed:
                return "ledger_not_ok"
        if provider in eligible_by_role.get(role, set()):
            return "eligible_but_not_selected"
        return "not_eligible"

    doctor_providers = doctor_payload.get("providers") if isinstance(doctor_payload, dict) else {}
    if not isinstance(doctor_providers, dict):
        doctor_providers = {}
    all_providers = sorted(set(providers_cfg.keys()) | set(doctor_providers.keys()))

    explain: dict[str, Any] = {}
    for name in all_providers:
        doc_entry = doctor_providers.get(name) if isinstance(doctor_providers, dict) else None
        doc_entry = doc_entry if isinstance(doc_entry, dict) else {}
        status = doc_entry.get("status") or "UNKNOWN"
        failures = doc_entry.get("failures") if isinstance(doc_entry.get("failures"), list) else []
        reason_code = None
        remediation: list[str] = []
        if failures:
            first = failures[0] if isinstance(failures[0], dict) else {}
            reason_code = first.get("code")
            remediation = (
                first.get("remediation") if isinstance(first.get("remediation"), list) else []
            )
        if not reason_code:
            reason_code = "OK" if status == "UP" else "UNKNOWN"

        included = included_roles.get(name, set())
        included_list = sorted(list(included))
        excluded_roles: dict[str, str] = {}
        if not included_list:
            for role_key, role_short in (
                ("brain", "brain"),
                ("council", "council"),
                ("vision", "vision"),
            ):
                excluded_roles[role_key] = _role_exclusion_reason(name, role_short)
        premium_reason_code = "included"
        if not included_list:
            premium_reason_code = (
                excluded_roles.get("brain")
                or excluded_roles.get("council")
                or excluded_roles.get("vision")
                or "not_eligible"
            )

        explain[name] = {
            "status": status,
            "reason_code": reason_code,
            "remediation": remediation,
            "starting_xi": {
                "included": bool(included_list),
                "included_roles": included_list,
                "excluded_roles": excluded_roles,
                "reason_code": premium_reason_code,
            },
        }

    return {
        "ok": True,
        "cost_mode": cost_mode,
        "rail": rail,
        "risk_level": risk_level,
        "latency_penalty": "ignored",
        "starting_xi_path": sx.get("path"),
        "providers": explain,
    }


def cmd_doctor_providers(args: argparse.Namespace) -> int:
    from agency.provider_health import run_provider_doctor  # type: ignore
    from agency.incidents import IncidentReporter  # type: ignore

    roles = args.roles or ["brain"]
    open_incident = bool(getattr(args, "incident", False))
    try:
        artifact_path, payload = run_provider_doctor(ROOT, roles=roles)
    except Exception as exc:
        print(f"Fallo al ejecutar doctor providers: {exc}", file=sys.stderr)
        return 2
    providers = payload.get("providers", {})
    summary = {
        name: data.get("status") for name, data in providers.items() if isinstance(data, dict)
    }
    output = {
        "ok": True,
        "artifact": str(artifact_path),
        "providers": summary,
    }
    provider_failures = [
        {"provider": name, "status": data.get("status"), "failures": data.get("failures")}
        for name, data in providers.items()
        if isinstance(data, dict) and data.get("status") != "UP"
    ]
    if getattr(args, "explain", False):
        output["starting_xi_explain"] = _explain_starting_xi_providers(
            ROOT, payload, cost_mode="premium"
        )
    should_open_incident = open_incident and (
        provider_failures or payload.get("incident_suggestion")
    )
    if should_open_incident:
        reporter = IncidentReporter(ROOT)
        attachments = [str(artifact_path)]
        env_snapshot = payload.get("doctor_env", {}).get("snapshot_path")
        if env_snapshot:
            attachments.append(env_snapshot)
        context = {"provider_failures": provider_failures}
        remediation = [
            "Revisar artifacts/health/providers/doctor_* para evidencia",
            "Asignar dueños a cada failure code.",
        ]
        incident_id = reporter.open_incident(
            kind="provider_health",
            summary="Doctor providers reporta degradaciones",
            context=context,
            remediation=remediation,
            attachments=attachments,
        )
        output["incident_id"] = incident_id
    print(json.dumps(output, ensure_ascii=False, indent=2))
    if any(status and status != "UP" for status in summary.values()):
        return 1
    return 0


def cmd_doctor_bridge(args: argparse.Namespace) -> int:
    try:
        from agency.bridge_doctor import run_bridge_doctor, persist_bridge_doctor  # type: ignore
    except Exception as exc:
        print(f"Bridge doctor no disponible: {exc}", file=sys.stderr)
        return 3
    providers = args.providers or None
    try:
        payload = run_bridge_doctor(ROOT, providers=providers, timeout_s=float(args.timeout))
    except Exception as exc:
        print(f"Fallo al ejecutar doctor bridge: {exc}", file=sys.stderr)
        return 2
    artifact = persist_bridge_doctor(ROOT, payload)
    overall_ok = bool(payload.get("ok", True))
    output = {
        "ok": overall_ok,
        "artifact": str(artifact),
        "summary": payload.get("summary", {}),
        "providers": payload.get("providers", {}),
    }
    print(json.dumps(output, ensure_ascii=False, indent=2))
    if not overall_ok:
        return 1
    if any(
        isinstance(entry, dict) and entry.get("status") not in {"OK", "UP"}
        for entry in output.get("providers", {}).values()
    ):
        return 1
    return 0


def cmd_doctor_leann(args: argparse.Namespace) -> int:
    ts = time.strftime("%Y%m%d_%H%M%S")
    out_dir = ROOT / "artifacts" / "doctor"
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / f"leann_{ts}.json"

    def _win_to_wsl_path(win_path: str) -> Optional[Path]:
        if len(win_path) >= 3 and win_path[1] == ":":
            drive = win_path[0].lower()
            tail = win_path[2:].lstrip("\\/")
            return Path("/mnt") / drive / Path(tail.replace("\\", "/"))
        return None

    checks = {}
    reasons = []

    public_root = Path(os.getenv("PUBLIC") or r"C:\Users\Public")
    public_candidates = [
        public_root / ".leann" / "os_api_key",
        public_root / ".ajax" / "ajax_api_key.txt",
    ]
    if os.name != "nt":
        public_candidates.extend(
            [
                Path("/mnt/c/Users/Public/.leann/os_api_key"),
                Path("/mnt/c/Users/Public/.ajax/ajax_api_key.txt"),
            ]
        )
    key_candidates = [
        ROOT / ".secret" / "ajax_api_key.txt",
        ROOT / ".secrets" / "ajax_api_key.txt",
        *public_candidates,
    ]
    key_checked = [str(p) for p in key_candidates]
    env_key = os.getenv("AJAX_API_KEY") or os.getenv("OS_DRIVER_API_KEY")
    key_found = next((p for p in key_candidates if p.exists()), None)
    key_ok = bool(env_key) or key_found is not None
    if not key_ok:
        reasons.append("missing_ajax_api_key")
    checks["ajax_api_key"] = {
        "ok": key_ok,
        "env_ajax_api_key": bool(env_key),
        "checked_paths": key_checked,
        "found_path": str(key_found) if key_found else None,
    }

    collection = os.getenv("AJAX_HISTORY_COLLECTION", "ajax_history_v1.leann")
    collection_path = Path(collection)
    if not collection_path.is_absolute():
        collection_path = (ROOT / collection_path).resolve()
    idx_candidates = [
        collection_path,
        collection_path.with_suffix(collection_path.suffix + ".index"),
        collection_path.with_suffix(collection_path.suffix + ".meta.json"),
    ]
    idx_found = [str(p) for p in idx_candidates if p.exists()]
    idx_ok = len(idx_found) > 0
    if not idx_ok:
        reasons.append("missing_leann_index")
    checks["index"] = {
        "ok": idx_ok,
        "collection": str(collection_path),
        "checked_paths": [str(p) for p in idx_candidates],
        "found_paths": idx_found,
    }

    query_cmd = [
        sys.executable,
        str(ROOT / "bin" / "leann_query.py"),
        "--query",
        "AJAX_PROTOCOL_CANON",
        "--top-k",
        "1",
    ]
    if os.getenv("AJAX_HISTORY_COLLECTION"):
        query_cmd.extend(["--collection", collection])

    query_ok = False
    query_detail = ""
    source_mode = None
    results_len = 0

    def _parse_json_payload(raw: str):
        raw = raw.strip()
        if not raw:
            return None, "empty_stdout"
        try:
            return json.loads(raw), None
        except json.JSONDecodeError as exc:
            start = raw.find("{")
            end = raw.rfind("}")
            if start != -1 and end != -1 and end > start:
                try:
                    return json.loads(raw[start : end + 1]), "trimmed_stdout"
                except json.JSONDecodeError as exc2:
                    return None, f"invalid_json:{exc2}"
            return None, f"invalid_json:{exc}"

    try:
        proc = subprocess.run(query_cmd, capture_output=True, text=True, check=False)
        if proc.returncode != 0:
            query_detail = proc.stderr.strip() or "leann_query_failed"
        else:
            payload, parse_note = _parse_json_payload(proc.stdout or "")
            if payload is None:
                query_detail = f"leann_query_invalid_json:{parse_note}"
            else:
                results = payload.get("results") if isinstance(payload, dict) else []
                results_len = len(results) if isinstance(results, list) else 0
                source_mode = payload.get("source_mode") if isinstance(payload, dict) else None
                if results_len > 0:
                    query_ok = True
                else:
                    query_detail = "leann_query_no_results"
                if parse_note and query_ok:
                    query_detail = f"leann_query_output_{parse_note}"
    except FileNotFoundError as exc:
        query_detail = f"leann_query_exec_missing:{exc}"

    if not query_ok:
        reasons.append("leann_query_failed")
    checks["query"] = {
        "ok": query_ok,
        "command": " ".join(query_cmd),
        "results": results_len,
        "source_mode": source_mode,
        "detail": query_detail or None,
    }

    ok = all(check.get("ok") for check in checks.values())
    payload = {
        "ok": ok,
        "ts": ts,
        "checks": checks,
        "reasons": reasons,
        "output_path": str(out_path),
    }
    out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
    print(json.dumps(payload, ensure_ascii=False, indent=2))
    return 0 if ok else 2


def _find_latest_doctor_artifact(root: Path) -> Optional[Path]:
    directory = root / "artifacts" / "health" / "providers"
    if not directory.exists():
        return None
    files = sorted(directory.glob("doctor_*.json"), key=lambda p: p.stat().st_mtime, reverse=True)
    return files[0] if files else None


def cmd_incident_open(args: argparse.Namespace) -> int:
    from agency.incidents import IncidentReporter  # type: ignore

    reporter = IncidentReporter(ROOT)
    attachments: list[str] = []
    context: dict[str, Any] = {}
    if getattr(args, "attach_last_doctor", False):
        latest = _find_latest_doctor_artifact(ROOT)
        if not latest:
            print("No se encontró artifacts/health/providers/doctor_*.json.", file=sys.stderr)
            return 2
        attachments.append(str(latest))
        try:
            payload = json.loads(latest.read_text(encoding="utf-8"))
            env_path = (
                payload.get("doctor_env", {}).get("snapshot_path")
                if isinstance(payload.get("doctor_env"), dict)
                else None
            )
            if env_path:
                attachments.append(env_path)
            context["doctor_snapshot"] = payload.get("providers")
        except Exception:
            pass
    remediation = args.remediation or []
    incident_id = reporter.open_incident(
        kind=args.kind,
        summary=args.summary or f"Incidente {args.kind}",
        context=context,
        remediation=remediation,
        attachments=attachments or None,
    )
    output = {"ok": True, "incident_id": incident_id, "attachments": attachments}
    print(json.dumps(output, ensure_ascii=False, indent=2))
    return 0


def _ensure_crystallization_engine() -> CrystallizationEngine:
    if CrystallizationEngine is None:
        raise RuntimeError(
            "CrystallizationEngine no disponible (agency.crystallization no importable)."
        )
    return CrystallizationEngine(ROOT)


def cmd_crystallize_mission(args: argparse.Namespace) -> int:
    try:
        engine = _ensure_crystallization_engine()
        result = engine.crystallize_mission(args.mission_id)
    except (RuntimeError, CrystallizationError) as exc:
        print(f"No se pudo cristalizar misión: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return 0


def cmd_crystallize_auto(args: argparse.Namespace) -> int:
    enabled = args.mode.lower() == "on"
    try:
        AUTO_CRYSTALLIZE_FLAG.parent.mkdir(parents=True, exist_ok=True)
        AUTO_CRYSTALLIZE_FLAG.write_text("1\n" if enabled else "0\n", encoding="utf-8")
    except Exception as exc:
        print(f"No se pudo actualizar la bandera auto-crystallize: {exc}", file=sys.stderr)
        return 2
    payload = {"ok": True, "enabled": enabled, "flag_path": str(AUTO_CRYSTALLIZE_FLAG)}
    print(json.dumps(payload, ensure_ascii=False, indent=2))
    return 0


def _parse_cli_timestamp(value: Optional[str]) -> Optional[float]:
    if value is None:
        return None
    value = value.strip()
    if not value:
        return None
    try:
        return float(value)
    except ValueError:
        try:
            from datetime import datetime

            return datetime.fromisoformat(value).timestamp()
        except Exception:
            raise ValueError(f"No se pudo interpretar --since '{value}' como epoch o ISO8601.")


def _parse_duration_seconds(value: Optional[str]) -> Optional[float]:
    if value is None:
        return None
    text = str(value).strip().lower()
    if not text:
        return None
    unit = text[-1]
    if unit.isdigit():
        try:
            return float(text)
        except Exception:
            raise ValueError(f"No se pudo interpretar duración '{value}'.")
    num = text[:-1].strip()
    try:
        amount = float(num)
    except Exception:
        raise ValueError(f"No se pudo interpretar duración '{value}'.")
    if unit == "s":
        return amount
    if unit == "m":
        return amount * 60.0
    if unit == "h":
        return amount * 3600.0
    if unit == "d":
        return amount * 86400.0
    raise ValueError(f"Unidad de duración inválida en '{value}'. Usa s/m/h/d.")


def cmd_validate_recipe(args: argparse.Namespace) -> int:
    try:
        engine = _ensure_crystallization_engine()
        since_ts = _parse_cli_timestamp(args.since) if getattr(args, "since", None) else None
        result = engine.validate_recipe(
            args.recipe,
            runs=args.n,
            source=args.source,
            since_ts=since_ts,
            min_signals=args.min_signals,
            rail=args.rail,
        )
    except (RuntimeError, CrystallizationError, ValueError) as exc:
        print(f"Validación falló: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return 0 if result.get("ok") else 2


def cmd_promote_recipe(args: argparse.Namespace) -> int:
    try:
        engine = _ensure_crystallization_engine()
        result = engine.promote_recipe(args.recipe)
    except (RuntimeError, CrystallizationError) as exc:
        print(f"Promoción falló: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return 0


def cmd_promote_eligible(args: argparse.Namespace) -> int:
    try:
        engine = _ensure_crystallization_engine()
        since_ts = _parse_cli_timestamp(args.since) if getattr(args, "since", None) else None
        summary = engine.promote_eligible_batch(
            since_ts=since_ts,
            min_signals=args.min_signals,
            runs=args.runs,
            rail=args.rail,
            limit=args.limit,
        )
    except (RuntimeError, CrystallizationError, ValueError) as exc:
        print(f"Promoción batch falló: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(summary, ensure_ascii=False, indent=2))
    return 0


def cmd_lab_status(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    job_id = getattr(args, "job_id", None)
    if not job_id:
        payload = dict(store.state)
        payload["lab_worker"] = _lab_worker_status(ROOT)
        print(json.dumps(payload, indent=2, ensure_ascii=False))
        return 0
    try:
        job, job_path = store.load_job(job_id)
    except Exception as exc:
        print(f"No se pudo cargar el job: {exc}", file=sys.stderr)
        return 2
    info = store.annotate_job_staleness(job, job_path)
    payload = {
        "job": job,
        "job_path": str(job_path),
        "staleness": info,
        "lab_worker": _lab_worker_status(ROOT),
    }
    try:
        qpos = store.queue_position(str(job_id))
        if qpos:
            payload["queue_position"] = qpos
    except Exception:
        pass
    result = store.find_result_for_job(job_id)
    if result:
        payload["result"] = result[0]
        payload["result_path"] = str(result[1])
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def _run_lab_start(
    root_dir: Path,
    *,
    driver_url: Optional[str] = None,
    worker_id: Optional[str] = None,
) -> int:
    _hb_path, pid_path, _info_path = _lab_worker_paths(root_dir)
    try:
        from agency.lab_dummy_driver import ensure_dummy_driver  # type: ignore
    except Exception:
        ensure_dummy_driver = None  # type: ignore
    if pid_path.exists():
        try:
            pid = int(pid_path.read_text(encoding="utf-8").strip())
            if pid_running(pid):
                print("LAB worker ya esta en ejecucion.")
                return 0
        except Exception:
            pass
        try:
            pid_path.unlink()
        except Exception:
            pass
    dummy_info = None
    if ensure_dummy_driver is not None:
        try:
            dummy_info = ensure_dummy_driver(root_dir, host="127.0.0.1", port=5012)
        except Exception as exc:
            dummy_info = {"ok": False, "error": str(exc)[:200], "simulated": True}
        if isinstance(dummy_info, dict) and not bool(dummy_info.get("ok")):
            print(
                f"No se pudo levantar dummy driver LAB en 5012: {dummy_info.get('error') or 'unknown'}",
                file=sys.stderr,
            )
            return 2
        if isinstance(dummy_info, dict) and bool(dummy_info.get("started")):
            print("Dummy driver LAB iniciado en 5012 (simulated=true).")

    cmd = [
        sys.executable,
        "-m",
        "agency.lab_worker",
        "--root",
        str(root_dir),
        "--daemon",
        "--pidfile",
        str(pid_path),
    ]
    if driver_url:
        cmd.extend(["--driver-url", str(driver_url)])
    if worker_id:
        cmd.extend(["--worker-id", str(worker_id)])
    proc = subprocess.run(cmd, cwd=root_dir, text=True)
    if proc.returncode == 0:
        try:
            LabStateStore(root_dir).resume_lab_org(
                "lab_start",
                metadata={"source": "ajaxctl"},
            )
        except Exception:
            pass
    return int(proc.returncode)


def cmd_lab_start(args: argparse.Namespace) -> int:
    root_dir = ROOT
    try:
        if getattr(args, "root", None):
            root_dir = _detect_repo_root(getattr(args, "root", None))
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    return _run_lab_start(
        root_dir,
        driver_url=getattr(args, "driver_url", None),
        worker_id=getattr(args, "worker_id", None),
    )


def cmd_lab_stop(args: argparse.Namespace) -> int:
    _hb_path, pid_path, _info_path = _lab_worker_paths(ROOT)
    if not pid_path.exists():
        print("No hay pidfile de LAB worker; nada que parar.")
        return 0
    try:
        pid = int(pid_path.read_text(encoding="utf-8").strip())
    except Exception as exc:
        print(f"No se pudo leer pidfile: {exc}", file=sys.stderr)
        return 1
    try:
        os.kill(pid, signal.SIGTERM)
        time.sleep(0.2)
        if pid_running(pid):
            os.kill(pid, signal.SIGKILL)
        print(f"Enviado stop a LAB worker (pid={pid}).")
    except Exception as exc:
        print(f"No se pudo parar LAB worker: {exc}", file=sys.stderr)
        return 1
    finally:
        try:
            pid_path.unlink()
        except Exception:
            pass
    return 0


def cmd_lab_restart(args: argparse.Namespace) -> int:
    cmd_lab_stop(args)
    return cmd_lab_start(args)


def cmd_lab_queue(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    try:
        limit = int(getattr(args, "limit", 10) or 10)
    except Exception:
        limit = 10
    queue = store.list_queue(limit=limit)

    groups = []
    seen = set()
    for item in queue:
        fingerprint = str(item.get("intent_fingerprint") or "unknown")
        if fingerprint in seen:
            continue
        seen.add(fingerprint)
        members = [q for q in queue if str(q.get("intent_fingerprint") or "unknown") == fingerprint]
        foreground = any(bool(m.get("foreground")) for m in members)
        groups.append(
            {
                "intent_fingerprint": fingerprint,
                "count": len(members),
                "foreground": foreground,
                "representative": members[0] if members else None,
                "job_ids": [m.get("job_id") for m in members],
            }
        )

    if getattr(args, "json", False):
        print(
            json.dumps(
                {"queue": queue, "groups": groups, "limit": limit}, indent=2, ensure_ascii=False
            )
        )
        return 0

    print(
        "intent_fingerprint\tcount\tforeground\tjob_id\tstatus\tpriority\teffective_priority\tage\tobjective"
    )
    for group in groups:
        rep = group.get("representative") or {}
        objective = str(rep.get("objective") or "")
        if len(objective) > 60:
            objective = objective[:57] + "..."
        age = _fmt_age(rep.get("age_s"))
        fingerprint = str(group.get("intent_fingerprint") or "")
        if len(fingerprint) > 12:
            fingerprint = fingerprint[:12] + "..."
        fg_mark = "FG" if group.get("foreground") else "-"
        print(
            "\t".join(
                [
                    fingerprint,
                    str(group.get("count") or ""),
                    fg_mark,
                    str(rep.get("job_id") or ""),
                    str(rep.get("status") or ""),
                    str(rep.get("priority") or ""),
                    str(rep.get("effective_priority") or ""),
                    age,
                    objective,
                ]
            )
        )
    return 0


def cmd_lab_enqueue(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    objective = str(getattr(args, "objective", "") or "").strip()
    if not objective:
        print("Se requiere --objective para encolar un job.", file=sys.stderr)
        return 2
    priority_raw = getattr(args, "priority", None)
    priority = _parse_priority_value(priority_raw)
    if priority_raw is None:
        priority = 30
        priority_reason = "batch"
    else:
        priority_reason = "manual_override"
    mission_id = getattr(args, "mission_id", None) or "manual"
    params = _load_json_input(
        getattr(args, "params_file", None), getattr(args, "params_json", None)
    )
    if params is not None and not isinstance(params, dict):
        print("Los parametros del job deben ser un JSON object.", file=sys.stderr)
        return 2
    payload = {
        "mission_id": mission_id,
        "status": "QUEUED",
        "objective": objective,
        "planned_steps": [],
        "evidence_expected": [],
        "output_paths": [],
        "priority": priority,
        "priority_reason": priority_reason,
    }
    if getattr(args, "job_kind", None):
        payload["job_kind"] = str(args.job_kind).strip()
    if params:
        payload["params"] = params
    record = store.enqueue_job(payload)
    print(json.dumps(record, indent=2, ensure_ascii=False))
    return 0


def cmd_lab_acknowledge(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    path = store.acknowledge_result(args.job_id)
    if not path:
        print("Resultado LAB no encontrado para ese job.", file=sys.stderr)
        return 2
    payload = {"ok": True, "job_id": args.job_id, "result_path": str(path)}
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_lab_inbox(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    items = store.list_inbox_results(limit=int(getattr(args, "limit", 10) or 10))
    if getattr(args, "json", False):
        payload = []
        for result, path in items:
            out = dict(result)
            out["result_path"] = str(path)
            payload.append(out)
        print(json.dumps(payload, ensure_ascii=False, indent=2))
        return 0
    if not items:
        print("Inbox LAB: vacio")
        return 0
    print("job_id\toutcome\tack_status\trisk_level\tsummary")
    for result, _path in items:
        print(
            "\t".join(
                [
                    str(result.get("job_id") or ""),
                    str(result.get("outcome") or ""),
                    str(result.get("ack_status") or ""),
                    str(result.get("risk_level") or ""),
                    _shorten(result.get("summary") or "", max_len=80),
                ]
            )
        )
    return 0


def cmd_lab_cancel(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    try:
        job, job_path = store.cancel_job(args.job_id, reason="cli_cancel")
    except Exception as exc:
        print(f"No se pudo cancelar el job: {exc}", file=sys.stderr)
        return 2
    detached = _clear_waiting_payload_for_job(ROOT, args.job_id, cancel_reason="lab_job_cancelled")
    payload = {
        "ok": True,
        "job_id": job.get("job_id") or args.job_id,
        "status": job.get("status"),
        "job_path": str(job_path),
        "detached_waiting": detached,
    }
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_lab_requeue(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    try:
        record = store.requeue_job(args.job_id, reason="cli_requeue")
    except Exception as exc:
        print(f"No se pudo reencolar el job: {exc}", file=sys.stderr)
        return 2
    new_job_id = record.get("job_id") if isinstance(record, dict) else None
    waiting_updated = False
    if new_job_id:
        waiting_updated = _update_waiting_payload_job_id(ROOT, args.job_id, str(new_job_id))
    payload = {
        "ok": True,
        "job_id": new_job_id,
        "job_path": record.get("job_path") if isinstance(record, dict) else None,
        "requeue_of": args.job_id,
        "waiting_updated": waiting_updated,
    }
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_git_status(args: argparse.Namespace) -> int:
    timeout_s = float(getattr(args, "timeout", None) or _git_status_timeout_s())
    cwd = Path(getattr(args, "cwd", None) or ROOT)
    result = _run_git_status(cwd, timeout_s=timeout_s)
    receipt_payload = {
        "schema": "ajax.git_status.v1",
        "ts": time.time(),
        "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "cwd": str(cwd),
        "timeout_s": timeout_s,
        "status_mode": result.get("status_mode"),
        "cmd": result.get("cmd"),
        "exit_code": result.get("exit_code"),
        "duration_ms": result.get("duration_ms"),
        "fallback_used": bool(result.get("fallback_used")),
        "stdout_trunc": _truncate_output(result.get("stdout") or "", limit=4000),
        "stderr_trunc": _truncate_output(result.get("stderr") or "", limit=4000),
    }
    receipt_path = _write_git_status_receipt(ROOT, receipt_payload)
    out_payload = dict(receipt_payload)
    out_payload["receipt_path"] = receipt_path
    if getattr(args, "json", False):
        print(json.dumps(out_payload, ensure_ascii=False, indent=2))
        return 0
    stdout = result.get("stdout") or ""
    if stdout.strip():
        print(stdout.rstrip())
    mode = result.get("status_mode")
    print(
        f"status_mode={mode} receipt={os.path.relpath(receipt_path, ROOT) if receipt_path else 'n/a'}"
    )
    return 0


def _vision_base_url() -> str:
    base = (os.getenv("AJAX_VISION_BASE_URL") or "http://localhost:1235/v1").strip()
    return base.rstrip("/")


def _vision_status_probe(timeout_s: float = 1.5) -> Dict[str, Any]:
    try:
        import requests  # type: ignore
    except Exception as exc:
        return {"ok": False, "error": "requests_missing", "detail": str(exc)}
    base = _vision_base_url()
    for path in ("/health", "/"):
        url = base + path
        try:
            resp = requests.get(url, timeout=timeout_s)
            return {"ok": resp.status_code < 400, "status_code": resp.status_code, "url": url}
        except Exception as exc:
            last_err = str(exc)
            continue
    return {"ok": False, "error": "vision_unreachable", "detail": last_err, "url": base}


def cmd_vision_status(args: argparse.Namespace) -> int:
    timeout_s = float(getattr(args, "timeout", None) or 1.5)
    payload = _vision_status_probe(timeout_s=timeout_s)
    payload["schema"] = "ajax.vision_status.v1"
    payload["ts"] = time.time()
    payload["ts_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    payload["base_url"] = _vision_base_url()
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        status = "OK" if payload.get("ok") else "FAIL"
        detail = payload.get("error") or payload.get("detail") or payload.get("status_code")
        print(f"Vision: {status} base={payload.get('base_url')} detail={detail}")
    return 0


def cmd_retry_fresh(args: argparse.Namespace) -> int:
    mission_id = str(args.mission_id or "").strip()
    if not mission_id:
        print("mission_id requerido.", file=sys.stderr)
        return 2
    payload = _resolve_waiting_payload_for_mission(ROOT, mission_id)
    if not payload:
        print("No hay misión pendiente con ese mission_id.", file=sys.stderr)
        return 2
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    receipt_meta: Dict[str, Any] = {}
    json_mode = bool(getattr(args, "json", False))
    exec_receipt_path: Optional[str] = None
    outcome_ok: Optional[bool] = None
    outcome_error: Optional[str] = None

    def _execute_direct(intent: str, *, envelope_override=None, mission_mode=None) -> None:
        prev_ignore = os.environ.get("AJAX_IGNORE_WAITING_MISSION")
        os.environ["AJAX_IGNORE_WAITING_MISSION"] = "1"
        try:
            mode_arg = str(mission_mode or "auto").strip().lower()
            result = core.do(intent, mode=mode_arg, envelope_override=envelope_override)
        finally:
            if prev_ignore is None:
                os.environ.pop("AJAX_IGNORE_WAITING_MISSION", None)
            else:
                os.environ["AJAX_IGNORE_WAITING_MISSION"] = prev_ignore
        exec_payload: Dict[str, Any] = {
            "schema": "ajax.exec_receipt.v1",
            "ts": time.time(),
            "ts_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "verify_ok": bool(getattr(result, "success", False)),
            "error": getattr(result, "error", None),
            "path": getattr(result, "path", None),
            "intent": intent,
            "mission_id": getattr(getattr(core, "state", None), "mission_id", None),
        }
        exec_payload.update(receipt_meta)
        nonlocal exec_receipt_path, outcome_ok, outcome_error
        exec_receipt_path = _write_exec_receipt(ROOT, exec_payload)
        outcome_ok = bool(exec_payload.get("verify_ok"))
        outcome_error = exec_payload.get("error")
        if not json_mode:
            lines, _voice = _render_action_result(result, core.config.root_dir)
            for line in lines:
                print(line)
            if exec_receipt_path:
                rel = os.path.relpath(exec_receipt_path, ROOT)
                print(f"Resumen: {'OK' if exec_payload['verify_ok'] else 'FAIL'} receipt={rel}")

    handled = _execute_fresh_retry(
        ROOT,
        core,
        payload,
        execute_mission=_execute_direct,
        answer_meta=receipt_meta,
        silent=json_mode,
    )
    if json_mode:
        out = {
            "ok": bool(handled and outcome_ok),
            "retry_of": receipt_meta.get("retry_of"),
            "fresh_clone": receipt_meta.get("fresh_clone"),
            "new_mission_id": receipt_meta.get("retry_new_mission_id"),
            "error": outcome_error,
            "receipt_path": exec_receipt_path,
        }
        print(json.dumps(out, ensure_ascii=False, indent=2))
    return 0 if handled else 1


def cmd_lab_snap(args: argparse.Namespace) -> int:
    if capture_lab_snapshot is None:
        print("Snap LAB no disponible (lab_snap no importable).", file=sys.stderr)
        return 3
    if getattr(args, "selfcheck", False):
        if fetch_lab_driver_capabilities is None:
            print("Selfcheck no disponible (capabilities no importable).", file=sys.stderr)
            return 3
        driver_url = _resolve_lab_driver_url()
        try:
            payload = fetch_lab_driver_capabilities(driver_url=driver_url)
        except Exception as exc:
            print(f"LAB selfcheck falló: {exc} (driver={driver_url})", file=sys.stderr)
            if "driver_http_404" in str(exc):
                print(
                    "Sugerencia: el driver LAB no expone /capabilities. "
                    "Reinicia 5012 con el código actualizado (Start-AjaxDriver.ps1 -Port 5012).",
                    file=sys.stderr,
                )
            return 2
        caps = payload.get("capabilities") or {}
        shot = caps.get("screenshot") if isinstance(caps.get("screenshot"), dict) else {}
        backend = shot.get("backend_preferred") or "unknown"
        reason = shot.get("backend_reason") or "unknown"
        print(f"LAB screenshot backend: {backend} (reason={reason})")
        if _ux_profile() == "debug":
            print(json.dumps(caps, ensure_ascii=False, indent=2))
        return 0
    job_id = getattr(args, "job", None) or getattr(args, "job_id", None)
    if not job_id:
        print("Se requiere --job para capturar el snap LAB.", file=sys.stderr)
        return 2
    display_override = getattr(args, "display", None)
    try:
        store = LabStateStore(ROOT)
        job, job_path = store.load_job(str(job_id))
    except Exception as exc:
        print(f"No se pudo cargar el job: {exc}", file=sys.stderr)
        return 2
    mission_id = job.get("mission_id") if isinstance(job, dict) else None
    driver_url = _resolve_lab_driver_url()
    try:
        result = capture_lab_snapshot(
            root_dir=ROOT,
            job_id=str(job_id),
            mission_id=str(mission_id) if mission_id else None,
            active_window=bool(getattr(args, "active_window", False)),
            driver_url=driver_url,
            display_override=str(display_override) if display_override else None,
        )
    except Exception as exc:
        print(f"LAB snap falló: {exc} (driver={driver_url})", file=sys.stderr)
        if any(
            tok in str(exc)
            for tok in (
                "mss_not_available",
                "pillow_grab_not_available",
                "screenshot_backend_unavailable",
            )
        ):
            print(
                "Sugerencia: ejecuta `ajaxctl lab snap --selfcheck` para ver el backend activo.",
                file=sys.stderr,
            )
        try:
            rel_job = os.path.relpath(job_path, ROOT) if ROOT else str(job_path)
            print(f"Refs (job): {rel_job}", file=sys.stderr)
        except Exception:
            pass
        return 2
    if getattr(args, "with_vision", False):
        png_path = result.get("png_path")
        if png_path:
            vision_summary = _describe_snapshot_with_vision(str(png_path))
            if vision_summary:
                result["vision_summary"] = vision_summary
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return 0


def cmd_lab_prune(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    try:
        older_than_s = _parse_duration_seconds(getattr(args, "older_than", None))
    except ValueError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    try:
        before_ts = _parse_cli_timestamp(getattr(args, "before", None))
    except ValueError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    keep = getattr(args, "keep_per_fingerprint", None)
    if keep is not None:
        try:
            keep = int(keep)
        except Exception:
            print("Valor inválido para --keep-per-fingerprint (esperado int).", file=sys.stderr)
            return 2
    mode = "archive"
    if getattr(args, "delete", False):
        mode = "delete"
    elif getattr(args, "archive", False):
        mode = "archive"
    dry_run = bool(getattr(args, "dry_run", False))
    receipt = store.prune_terminal_jobs(
        older_than_s=older_than_s,
        before_ts=before_ts,
        keep_per_fingerprint=keep,
        mode=mode,
        dry_run=dry_run,
    )
    print(json.dumps(receipt, indent=2, ensure_ascii=False))
    return 0


def cmd_desktop_snap(args: argparse.Namespace) -> int:
    if capture_desktop_snapshot is None:
        print("Snap no disponible (desktop_snap no importable).", file=sys.stderr)
        return 3
    mission_id = getattr(args, "mission_id", None)
    job_id = getattr(args, "job_id", None)
    attach_to = getattr(args, "attach_to", None)
    display_override = getattr(args, "display", None)
    rail = getattr(args, "rail", None)
    if attach_to:
        payload, wait_mission_id, wait_job_id = _resolve_waiting_context(ROOT)
        if attach_to == "mission":
            mission_id = mission_id or wait_mission_id
        elif attach_to == "job":
            job_id = job_id or wait_job_id
        if not mission_id and attach_to == "mission":
            print("No hay mision en espera para adjuntar snap.", file=sys.stderr)
            return 2
        if not job_id and attach_to == "job":
            print("No hay job en espera para adjuntar snap.", file=sys.stderr)
            return 2
    ctx = mission_id or job_id or "manual"
    selection = None
    if resolve_display_selection and load_display_map:
        selection = resolve_display_selection(
            rail=_resolve_snap_rail(None, rail),
            displays=_safe_list_local_displays(),
            override=str(display_override) if display_override else None,
            display_map=load_display_map(ROOT),
        )
    try:
        result = capture_desktop_snapshot(
            root_dir=ROOT,
            active_window=bool(getattr(args, "active_window", False)),
            mission_id=mission_id,
            job_id=job_id,
            context=ctx,
            display_id=None,
            selection=selection,
        )
    except Exception as exc:
        print(f"Snap falló: {exc}", file=sys.stderr)
        return 2
    print(json.dumps(result, ensure_ascii=False, indent=2))
    return 0


def cmd_lab_web(args: argparse.Namespace) -> int:
    try:
        from agency.lab_web import run_lab_web
    except Exception as exc:
        print(f"LAB web no disponible: {exc}", file=sys.stderr)
        return 3
    payload = run_lab_web(
        args.topic,
        days=args.days,
        strict=bool(args.strict),
        max_results=int(args.max_results),
        allow_prod=False,
    )
    if getattr(args, "json", False):
        print(json.dumps(payload, ensure_ascii=False, indent=2))
    else:
        print(payload.get("report_path"))
    return 0 if payload.get("ok") else 2


def cmd_lab_pause_org(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    reason = args.reason or "cli_pause"
    changed = store.pause_lab_org(reason=reason, metadata={"source": "ajaxctl"})
    payload = {"ok": True, "status": store.state.get("lab_org"), "changed": changed}
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_lab_resume_org(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    reason = args.reason or "cli_resume"
    changed = store.resume_lab_org(reason=reason, metadata={"source": "ajaxctl"})
    payload = {"ok": True, "status": store.state.get("lab_org"), "changed": changed}
    print(json.dumps(payload, indent=2, ensure_ascii=False))
    return 0


def cmd_lab_probe_complete(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    recipe = _load_json_input(args.recipe_file, args.recipe_json)
    evidence = _load_json_input(args.evidence_file, args.evidence_json)
    notes = _load_json_input(None, args.notes_json) if getattr(args, "notes_json", None) else None
    if recipe is None:
        print("Se requiere --recipe-file o --recipe-json con el plan/recipe.", file=sys.stderr)
        return 2
    if evidence is None:
        print("Se requiere --evidence-file o --evidence-json con el EvidencePack.", file=sys.stderr)
        return 2
    payload, path = store.update_probe_outputs(
        args.probe,
        recipe=recipe,
        evidence_pack=evidence,
        transfer_confidence=float(args.confidence),
        notes=notes if isinstance(notes, dict) else None,
    )
    print(
        json.dumps(
            {"ok": True, "probe_path": str(path), "status": payload.get("status")},
            indent=2,
            ensure_ascii=False,
        )
    )
    if store.probe_ready_for_prod(payload):
        print("✅ Probe marcado como listo para reintegrarse en PROD.")
    else:
        print("ℹ Probe actualizado, pero aún no supera el umbral de reintegración.")
    return 0


def cmd_lab_probe_apply(args: argparse.Namespace) -> int:
    store = LabStateStore(ROOT)
    try:
        payload, path = store.load_probe(args.probe)
    except Exception as exc:
        print(f"No se pudo cargar el probe: {exc}", file=sys.stderr)
        return 2
    if not store.probe_ready_for_prod(payload):
        print(
            "Probe no cumple los criterios mínimos (EvidencePack/TransferConfidence).",
            file=sys.stderr,
        )
        return 2
    try:
        core = _get_core()
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 3
    try:
        result = core.run_lab_probe_recipe(payload, dry_run=bool(args.dry_run))
    except Exception as exc:
        print(f"No se pudo ejecutar el recipe: {exc}", file=sys.stderr)
        return 2
    payload_out = {
        "success": result.success,
        "error": result.error,
        "path": result.path,
        "detail": result.detail,
        "artifacts": result.artifacts,
        "probe_path": str(path),
    }
    print(json.dumps(payload_out, indent=2, ensure_ascii=False))
    return 0 if result.success else 2


def cmd_whereami(args: argparse.Namespace) -> int:
    try:
        repo_root = _detect_repo_root(args.root)
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    try:
        user = getpass.getuser()
    except Exception:
        user = os.environ.get("USERNAME") or os.environ.get("USER") or "unknown"
    print("AJAX whereami")
    print(f"repo_root: {repo_root}")
    print(f"user: {user}")
    print(f"cwd: {Path.cwd()}")
    print(f"python: {sys.executable}")
    print("env:")
    print(f"  AJAX_HOME={_whereami_env_value('AJAX_HOME')}")
    os_driver_keys = sorted(k for k in os.environ if k.startswith("OS_DRIVER_"))
    for key in os_driver_keys:
        print(f"  {key}={_whereami_env_value(key)}")
    return 0


def cmd_lab_init(args: argparse.Namespace) -> int:
    try:
        root_dir = _detect_repo_root(getattr(args, "root", None))
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 2
    if root_dir.name != "ajax-kernel":
        print(
            f"Root no canónico: {root_dir} (se esperaba basename 'ajax-kernel').",
            file=sys.stderr,
        )
        return 2
    try:
        from agency.lab_bootstrap import ensure_lab_bootstrap  # type: ignore
    except Exception as exc:
        print(f"LAB bootstrap no disponible: {exc}", file=sys.stderr)
        return 3
    try:
        payload = ensure_lab_bootstrap(root_dir)
    except Exception as exc:
        print(f"LAB init falló: {exc}", file=sys.stderr)
        return 2
    start_rc = None
    if bool(getattr(args, "start", False)):
        start_rc = _run_lab_start(
            root_dir,
            driver_url=getattr(args, "driver_url", None),
            worker_id=getattr(args, "worker_id", None),
        )
        payload["lab_start_rc"] = int(start_rc)
    print(json.dumps(payload, ensure_ascii=False, indent=2))
    if start_rc is not None and int(start_rc) != 0:
        return 2
    return 0 if bool(payload.get("ok")) else 2


def main(argv=None) -> int:
    parser = argparse.ArgumentParser(
        prog="ajaxctl", description="CLI para el núcleo AJAX (AjaxCore)."
    )
    sub = parser.add_subparsers(dest="command", required=True)

    p_do = sub.add_parser("do", help="Ejecuta una intención de alto nivel.")
    p_do.add_argument("intention", nargs=argparse.REMAINDER, help="Intención en lenguaje natural.")
    p_do.set_defaults(func=cmd_do)

    p_media_verify = sub.add_parser(
        "media-verify",
        help="Verifica reproducción real (YouTube + avance de tiempo + audio en Volume Mixer).",
    )
    p_media_verify.add_argument("--mission-id", help="Mission id para nombrar report_<mission>.json.")
    p_media_verify.add_argument("--browser-process", default="brave.exe", help="Proceso del navegador (default brave.exe).")
    p_media_verify.add_argument("--expected-artist", default="Extremoduro", help="Token esperado en el título.")
    p_media_verify.add_argument("--expected-title", default="Standby", help="Token esperado (Stand By/Standby).")
    p_media_verify.add_argument("--time-window-s", type=float, default=4.0, help="Ventana entre capturas del player (default 4.0s).")
    p_media_verify.add_argument("--min-time-delta-s", type=float, default=2.0, help="Delta mínimo de currentTime (default 2.0s).")
    p_media_verify.add_argument("--audio-motion-threshold", type=float, default=2.0, help="Umbral (0..255) para considerar barras moviéndose (default 2.0).")
    p_media_verify.set_defaults(func=cmd_media_verify)

    p_plan = sub.add_parser("plan", help="Genera un plan (planning-only, sin ejecutar acciones).")
    p_plan.add_argument(
        "intention", nargs=argparse.REMAINDER, help="Intención en lenguaje natural."
    )
    p_plan.add_argument(
        "--perceive",
        action="store_true",
        help="Incluye percepción (driver) antes de planificar. Por defecto: sin driver (foreground=None).",
    )
    p_plan.add_argument(
        "--exclude-provider",
        action="append",
        default=[],
        help="Excluye un provider Brain (puede repetirse). Ej: --exclude-provider codex_brain",
    )
    p_plan.set_defaults(func=cmd_plan)

    p_subcall = sub.add_parser(
        "subcall", help="DEV_DELEGATION: subcall (policy+ledger) para roles T0–T2."
    )
    p_subcall.add_argument(
        "--role", required=True, choices=["scout", "reviewer", "summarizer", "validator"]
    )
    p_subcall.add_argument("--tier", required=True, choices=["T0", "T1", "T2"])
    p_subcall.add_argument(
        "--json", action="store_true", help="Exige salida JSON + 1 repair pass si hace falta."
    )
    p_subcall.add_argument("--stdin", action="store_true", help="Lee el prompt desde stdin.")
    p_subcall.add_argument(
        "--allow-premium-subcall",
        action="store_true",
        help="Permite providers premium/codex en subcall (override explícito).",
    )
    p_subcall.add_argument(
        "--smoke-bypass-ledger",
        action="store_true",
        help="SMOKE: ignora provider_ledger (no afecta lógica core).",
    )
    p_subcall.add_argument(
        "--smoke-force-provider",
        help="SMOKE: fuerza provider al principio del ladder (ej: codex_brain).",
    )
    p_subcall.add_argument("prompt", nargs=argparse.REMAINDER, help="Prompt (si no usas --stdin).")
    p_subcall.set_defaults(func=cmd_subcall)

    p_health = sub.add_parser("health", help="Chequea el estado del sistema AJAX.")
    p_health.add_argument("--json", action="store_true", help="Salida JSON sin resumen extra.")
    p_health.set_defaults(func=cmd_health)

    p_cloud_canary = sub.add_parser(
        "cloud-canary", help="Canary determinista para proveedor cloud."
    )
    p_cloud_canary.add_argument(
        "--provider", required=True, help="Provider (ej: groq, qwen_cloud, gemini_cli)."
    )
    p_cloud_canary.add_argument("--model", help="Modelo explícito (si aplica).")
    p_cloud_canary.add_argument("--json", action="store_true", help="Salida JSON.")
    p_cloud_canary.set_defaults(func=cmd_cloud_canary)

    p_cloud_bench = sub.add_parser("cloud-bench", help="Benchmark cloud (suite crawl_v1).")
    p_cloud_bench.add_argument("--suite", default="crawl_v1", help="Suite (default crawl_v1).")
    p_cloud_bench.add_argument(
        "--providers", nargs="*", help="Lista de providers (si se omite usa fallback chain)."
    )
    p_cloud_bench.add_argument("--runs", type=int, default=3, help="Runs por test (default 3).")
    p_cloud_bench.add_argument("--budget", default="tiny", help="Budget label (tiny|small|...).")
    p_cloud_bench.add_argument("--json", action="store_true", help="Salida JSON.")
    p_cloud_bench.add_argument(
        "--allow-premium-subcall",
        action="store_true",
        help="Permite providers premium/codex en bench.",
    )
    p_cloud_bench.add_argument(
        "--confirm-premium",
        help="Token de confirmación premium (CONFIRMO PREMIUM).",
    )
    p_cloud_bench.set_defaults(func=cmd_cloud_bench)

    p_lmstudio_bench = sub.add_parser(
        "lmstudio-bench", help="Benchmark LM Studio (suite crawl_v1)."
    )
    p_lmstudio_bench.add_argument("--suite", default="crawl_v1", help="Suite (default crawl_v1).")
    p_lmstudio_bench.add_argument(
        "--models", default="all", help="Modelos: all | regex | ids (comma)."
    )
    p_lmstudio_bench.add_argument("--runs", type=int, default=3, help="Runs por test (default 3).")
    p_lmstudio_bench.add_argument(
        "--select-best", action="store_true", help="Escribe fallback_local_model.json."
    )
    p_lmstudio_bench.add_argument("--json", action="store_true", help="Salida JSON.")
    p_lmstudio_bench.set_defaults(func=cmd_lmstudio_bench)

    p_lmstudio_test = sub.add_parser(
        "lmstudio-test", help="Canary LM Studio usando fallback_local_model.json."
    )
    p_lmstudio_test.add_argument("--json", action="store_true", help="Salida JSON.")
    p_lmstudio_test.set_defaults(func=cmd_lmstudio_test)

    p_ledger = sub.add_parser(
        "ledger", help="Ledger/Budgeter: estado vivo de providers/modelos (JSON o tabla)."
    )
    fmt = p_ledger.add_mutually_exclusive_group()
    fmt.add_argument("--json", action="store_true", help="Salida JSON (incluye rows[]).")
    fmt.add_argument("--table", action="store_true", help="Salida tabular (por defecto).")
    p_ledger.add_argument(
        "--no-refresh",
        action="store_true",
        help="No hacer probes; leer el último ledger persistido.",
    )
    p_ledger.set_defaults(func=cmd_ledger)

    p_providers = sub.add_parser("providers", help="Inventario + preflight de providers.")
    providers_sub = p_providers.add_subparsers(dest="providers_cmd", required=True)
    p_providers_status = providers_sub.add_parser(
        "status", help="Preflight y snapshot de providers."
    )
    p_providers_status.add_argument("--json", action="store_true", help="Salida en JSON.")
    p_providers_status.add_argument(
        "--no-refresh", action="store_true", help="No refrescar ledger (usa latest.json)."
    )
    p_providers_status.set_defaults(func=cmd_providers_status)
    p_providers_ping = providers_sub.add_parser(
        "ping", help="Ping con TTFT/total para un provider."
    )
    p_providers_ping.add_argument(
        "--provider", required=True, help="Provider (ej: codex_brain, gemini_cli)."
    )
    p_providers_ping.add_argument("--model", help="Modelo explícito (si aplica).")
    p_providers_ping.add_argument(
        "--timeout-ttft",
        type=int,
        dest="timeout_ttft",
        help="Timeout TTFT en ms (override).",
    )
    p_providers_ping.add_argument(
        "--timeout-total",
        type=int,
        dest="timeout_total",
        help="Timeout total en ms (override).",
    )
    p_providers_ping.add_argument(
        "--timeout-stall",
        type=int,
        dest="timeout_stall",
        help="Timeout stall en ms (override).",
    )
    p_providers_ping.add_argument("--json", action="store_true", help="Salida JSON.")
    p_providers_ping.set_defaults(func=cmd_provider_ping)

    p_provider = sub.add_parser("provider", help="Alias: utilidades de provider.")
    provider_sub = p_provider.add_subparsers(dest="provider_cmd", required=True)
    p_provider_ping = provider_sub.add_parser("ping", help="Ping de provider (alias).")
    p_provider_ping.add_argument(
        "--provider", required=True, help="Provider (ej: codex_brain, gemini_cli)."
    )
    p_provider_ping.add_argument("--model", help="Modelo explícito (si aplica).")
    p_provider_ping.add_argument(
        "--timeout-ttft",
        type=int,
        dest="timeout_ttft",
        help="Timeout TTFT en ms (override).",
    )
    p_provider_ping.add_argument(
        "--timeout-total",
        type=int,
        dest="timeout_total",
        help="Timeout total en ms (override).",
    )
    p_provider_ping.add_argument(
        "--timeout-stall",
        type=int,
        dest="timeout_stall",
        help="Timeout stall en ms (override).",
    )
    p_provider_ping.add_argument("--json", action="store_true", help="Salida JSON.")
    p_provider_ping.set_defaults(func=cmd_provider_ping)

    p_models = sub.add_parser("models", help="Catalogos y utilidad de modelos.")
    p_models_sub = p_models.add_subparsers(dest="models_cmd", required=True)
    p_models_available = p_models_sub.add_parser(
        "available", help="Inventario de modelos detectados."
    )
    amfmt = p_models_available.add_mutually_exclusive_group()
    amfmt.add_argument("--json", action="store_true", help="Salida JSON.")
    amfmt.add_argument("--table", action="store_true", help="Salida tabular (por defecto).")
    p_models_available.set_defaults(func=cmd_models_available)

    p_models_utility = p_models_sub.add_parser(
        "utility", help="Model Utility Catalog (show|bootstrap)."
    )
    p_models_utility.add_argument(
        "action", nargs="?", default="show", choices=["show", "bootstrap"]
    )
    mfmt = p_models_utility.add_mutually_exclusive_group()
    mfmt.add_argument("--json", action="store_true", help="Salida JSON.")
    mfmt.add_argument("--table", action="store_true", help="Salida tabular (por defecto).")
    p_models_utility.set_defaults(func=cmd_models_utility)

    p_agent = sub.add_parser("agent", help="Protocolo de Autonomía Supervisada (PAS).")
    p_agent.add_argument("goal", nargs=argparse.REMAINDER, help="Goal de alto nivel (agent_goal).")
    p_agent.add_argument(
        "--max-missions", type=int, default=3, help="Máximo de misiones por sesión PAS."
    )
    p_agent.add_argument(
        "--max-runtime", type=int, default=420, help="Tiempo máximo de sesión (segundos)."
    )
    p_agent.add_argument(
        "--max-failures",
        type=int,
        default=2,
        help="Fallos consecutivos permitidos antes de abortar.",
    )
    p_agent.add_argument("--voice", action="store_true", help="Leer por voz el resultado final.")
    p_agent.set_defaults(func=cmd_agent)

    p_retry_fresh = sub.add_parser(
        "retry-fresh", help="Reintenta una misión pendiente como misión nueva."
    )
    p_retry_fresh.add_argument("mission_id", help="Mission ID pendiente (waiting_mission.json).")
    p_retry_fresh.add_argument("--json", action="store_true", help="Salida JSON.")
    p_retry_fresh.set_defaults(func=cmd_retry_fresh)

    p_git_status = sub.add_parser("git-status", help="Estado git con timeout y fallback.")
    p_git_status.add_argument("--timeout", type=float, help="Timeout en segundos (override).")
    p_git_status.add_argument("--cwd", help="Directorio de trabajo (default: ROOT).")
    p_git_status.add_argument("--json", action="store_true", help="Salida JSON.")
    p_git_status.set_defaults(func=cmd_git_status)

    p_vision_status = sub.add_parser(
        "vision-status", help="Ping rápido de visión local (localhost:1235)."
    )
    p_vision_status.add_argument("--timeout", type=float, help="Timeout en segundos (override).")
    p_vision_status.add_argument("--json", action="store_true", help="Salida JSON.")
    p_vision_status.set_defaults(func=cmd_vision_status)

    p_chat = sub.add_parser("chat", help="Inicia una sesión interactiva (loop).")
    p_chat.add_argument(
        "--voice", "-v", action="store_true", help="Reproducir respuestas por voz (edge-tts)."
    )
    p_chat.add_argument(
        "--tier",
        choices=["premium", "balanced", "emergency"],
        help="Tier preferido (default: premium).",
    )
    p_chat.add_argument(
        "--allow-local",
        action="store_true",
        help="Alias de --allow-local-text (permitir local_text).",
    )
    p_chat.add_argument(
        "--allow-local-text",
        action="store_true",
        help="Permite providers locales de texto en esta sesión.",
    )
    chat_lite_group = p_chat.add_mutually_exclusive_group()
    chat_lite_group.add_argument(
        "--chat-lite", action="store_true", help="Forzar Chat-Lite en esta sesión."
    )
    chat_lite_group.add_argument(
        "--no-chat-lite", action="store_true", help="Desactivar Chat-Lite en esta sesión."
    )
    p_chat.set_defaults(func=cmd_chat)

    p_whereami = sub.add_parser(
        "whereami", help="Imprime contexto de ejecucion (root, usuario, entorno)."
    )
    p_whereami.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_whereami.set_defaults(func=cmd_whereami)

    p_microfilm = sub.add_parser("microfilm", help="Microfilm Compliance v1 checks.")
    microfilm_sub = p_microfilm.add_subparsers(dest="microfilm_cmd", required=True)
    p_microfilm_check = microfilm_sub.add_parser(
        "check", help="Ejecuta doctor mínimo + guards Microfilm fail-closed."
    )
    p_microfilm_check.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_microfilm_check.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_microfilm_check.set_defaults(func=cmd_microfilm_check)

    p_audit = sub.add_parser("audit", help="Auditorías operativas read-only.")
    try:
        from agency.audits.runner import list_registered_audits as _list_registered_audits  # type: ignore

        _audit_names = sorted(_list_registered_audits().keys())
    except Exception:
        _audit_names = []
    p_audit.add_argument(
        "audit_name",
        nargs="?",
        choices=_audit_names if _audit_names else None,
        help=(
            "Nombre de auditoría"
            + (f" ({', '.join(_audit_names)})" if _audit_names else "")
            + "."
        ),
    )
    p_audit.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_audit_scope = p_audit.add_mutually_exclusive_group()
    p_audit_scope.add_argument("--run", dest="run_id", help="Run ID específico a auditar.")
    p_audit_scope.add_argument(
        "--last", type=int, default=1, help="Audita los últimos N runs (default: 1)."
    )
    p_audit.add_argument("--json", action="store_true", help="Salida JSON.")
    p_audit.set_defaults(func=cmd_audit)

    p_soak = sub.add_parser("soak", help="Soak Gate v1 (arranque/reanudo/horas).")
    soak_sub = p_soak.add_subparsers(dest="soak_cmd", required=True)
    p_soak_check = soak_sub.add_parser("check", help="Ejecuta soak gate ALIVE/EFFECTIVE/SAFE.")
    p_soak_check.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_soak_check.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_soak_check.add_argument(
        "--window-min",
        type=int,
        default=60,
        help="Ventana en minutos para actividad efectiva (default 60).",
    )
    p_soak_check.set_defaults(func=cmd_soak_check)

    p_tools = sub.add_parser("tools", help="Inventario y estado de tools.")
    p_tools_sub = p_tools.add_subparsers(dest="tools_cmd", required=True)
    p_tools_show = p_tools_sub.add_parser("show", help="Muestra inventario canónico.")
    p_tools_show.set_defaults(func=cmd_tools_show)
    p_tools_status = p_tools_sub.add_parser(
        "status", help="Snapshot de estado de tools y heartbeat."
    )
    p_tools_status.set_defaults(func=cmd_tools_status)
    p_tools_sync = p_tools_sub.add_parser("sync", help="Sync offline/plantilla (opcional).")
    p_tools_sync.set_defaults(func=cmd_tools_sync)
    p_tools_notes = p_tools_sub.add_parser("notes", help="Muestra Tool Use Notes acumuladas.")
    p_tools_notes.set_defaults(func=cmd_tools_notes)

    p_lab = sub.add_parser("lab", help="Controles LAB dual (ORG/PROBE).")
    lab_sub = p_lab.add_subparsers(dest="lab_cmd", required=True)
    p_lab_init = lab_sub.add_parser("init", help="Bootstrap seguro de LAB (idempotente).")
    p_lab_init.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_lab_init.add_argument("--start", action="store_true", help="Arranca LAB worker al finalizar.")
    p_lab_init.add_argument("--driver-url", help="Override URL del driver LAB al arrancar.")
    p_lab_init.add_argument("--worker-id", help="Override ID del worker al arrancar.")
    p_lab_init.set_defaults(func=cmd_lab_init)
    p_lab_start = lab_sub.add_parser("start", help="Arranca el LAB worker.")
    p_lab_start.add_argument("--root", help="Override de repo_root (AJAX_HOME).")
    p_lab_start.add_argument("--driver-url", help="Override URL del driver LAB.")
    p_lab_start.add_argument("--worker-id", help="Override ID del worker.")
    p_lab_start.set_defaults(func=cmd_lab_start)
    p_lab_stop = lab_sub.add_parser("stop", help="Detiene el LAB worker.")
    p_lab_stop.set_defaults(func=cmd_lab_stop)
    p_lab_restart = lab_sub.add_parser("restart", help="Reinicia el LAB worker.")
    p_lab_restart.add_argument("--driver-url", help="Override URL del driver LAB.")
    p_lab_restart.add_argument("--worker-id", help="Override ID del worker.")
    p_lab_restart.set_defaults(func=cmd_lab_restart)
    p_lab_status = lab_sub.add_parser("status", help="Muestra lab_control.json.")
    p_lab_status.add_argument("job_id", nargs="?", help="ID opcional de job LAB.")
    p_lab_status.set_defaults(func=cmd_lab_status)
    p_lab_queue = lab_sub.add_parser("queue", help="Muestra la cola LAB ordenada.")
    p_lab_queue.add_argument("--limit", type=int, default=10, help="Maximo de jobs a listar.")
    p_lab_queue.add_argument("--json", action="store_true", help="Salida JSON.")
    p_lab_queue.set_defaults(func=cmd_lab_queue)
    p_lab_enqueue = lab_sub.add_parser("enqueue", help="Encola un job LAB manual.")
    p_lab_enqueue.add_argument("--objective", required=True, help="Objetivo del job.")
    p_lab_enqueue.add_argument("--mission-id", help="Mission id opcional.")
    p_lab_enqueue.add_argument(
        "--kind", dest="job_kind", help="Tipo de job (snap_lab, probe_ui, probe_notepad)."
    )
    p_lab_enqueue.add_argument("--params-file", help="Ruta a JSON con parametros del job.")
    p_lab_enqueue.add_argument("--params-json", help="JSON inline con parametros del job.")
    p_lab_enqueue.add_argument(
        "--priority",
        help="Prioridad 0..100 o etiqueta high|med|low (default: low/batch).",
    )
    p_lab_enqueue.set_defaults(func=cmd_lab_enqueue)
    p_lab_ack = lab_sub.add_parser("acknowledge", help="Marca outcome LAB como visto.")
    p_lab_ack.add_argument("job_id", help="ID del job LAB.")
    p_lab_ack.set_defaults(func=cmd_lab_acknowledge)
    p_lab_inbox = lab_sub.add_parser("inbox", help="Lista outcomes LAB pendientes de ACK.")
    p_lab_inbox.add_argument("--limit", type=int, default=10, help="Maximo de resultados.")
    p_lab_inbox.add_argument("--json", action="store_true", help="Salida JSON.")
    p_lab_inbox.set_defaults(func=cmd_lab_inbox)
    p_lab_cancel = lab_sub.add_parser("cancel", help="Cancela un job LAB.")
    p_lab_cancel.add_argument("job_id", help="ID del job LAB.")
    p_lab_cancel.set_defaults(func=cmd_lab_cancel)
    p_lab_requeue = lab_sub.add_parser("requeue", help="Reencola un job LAB.")
    p_lab_requeue.add_argument("job_id", help="ID del job LAB.")
    p_lab_requeue.set_defaults(func=cmd_lab_requeue)
    p_lab_snap = lab_sub.add_parser("snap", help="Captura screenshot del desktop LAB.")
    p_lab_snap.add_argument("--job", help="ID del job LAB.")
    p_lab_snap.add_argument(
        "--active-window", action="store_true", help="Captura solo la ventana activa."
    )
    p_lab_snap.add_argument(
        "--display",
        help="Override display (id|dummy|primary|lab|prod).",
    )
    p_lab_snap.add_argument(
        "--with-vision", action="store_true", help="Describe la captura usando vision."
    )
    p_lab_snap.add_argument(
        "--selfcheck", action="store_true", help="Diagnostico del backend de screenshot."
    )
    p_lab_snap.set_defaults(func=cmd_lab_snap)
    p_lab_prune = lab_sub.add_parser("prune", help="Prune de jobs LAB terminales (archive/delete).")
    time_group = p_lab_prune.add_mutually_exclusive_group()
    time_group.add_argument("--older-than", help="Filtro de antigüedad (ej. 7d, 12h, 30m).")
    time_group.add_argument(
        "--before", help="Epoch o ISO8601: conserva jobs posteriores a este timestamp."
    )
    p_lab_prune.add_argument(
        "--keep-per-fingerprint", type=int, default=None, help="Mantener N jobs por fingerprint."
    )
    mode_group = p_lab_prune.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--archive", action="store_true", help="Mover a artifacts/lab/archive/<ts>."
    )
    mode_group.add_argument("--delete", action="store_true", help="Eliminar definitivamente.")
    p_lab_prune.add_argument(
        "--dry-run", action="store_true", help="Solo simula, no mueve ni borra."
    )
    p_lab_prune.set_defaults(func=cmd_lab_prune)
    p_lab_web = lab_sub.add_parser("web", help="LAB web discovery (no LLM).")
    p_lab_web.add_argument("--topic", required=True, help="Tema a buscar.")
    p_lab_web.add_argument(
        "--days", type=int, default=None, help="Limite temporal en dias (opcional)."
    )
    p_lab_web.add_argument("--strict", action="store_true", help="Falla si no hay resultados.")
    p_lab_web.add_argument("--json", action="store_true", help="Salida JSON en stdout.")
    p_lab_web.add_argument("--max-results", type=int, default=8, help="Maximo de resultados.")
    p_lab_web.set_defaults(func=cmd_lab_web)
    p_lab_pause = lab_sub.add_parser("pause-org", help="Pausa LAB_ORG y persiste snapshot.")
    p_lab_pause.add_argument("--reason", help="Motivo opcional.")
    p_lab_pause.set_defaults(func=cmd_lab_pause_org)
    p_lab_resume = lab_sub.add_parser("resume-org", help="Reanuda LAB_ORG tras una pausa.")
    p_lab_resume.add_argument("--reason", help="Motivo opcional.")
    p_lab_resume.set_defaults(func=cmd_lab_resume_org)
    p_lab_probe_complete = lab_sub.add_parser(
        "probe-complete", help="Actualiza outputs (Recipe/EvidencePack) de un LAB_PROBE."
    )
    p_lab_probe_complete.add_argument("--probe", required=True, help="ID o ruta del probe.")
    p_lab_probe_complete.add_argument("--recipe-file", help="Ruta a JSON con el recipe.")
    p_lab_probe_complete.add_argument("--recipe-json", help="JSON inline con el recipe.")
    p_lab_probe_complete.add_argument("--evidence-file", help="Ruta a JSON con EvidencePack.")
    p_lab_probe_complete.add_argument("--evidence-json", help="JSON inline con EvidencePack.")
    p_lab_probe_complete.add_argument(
        "--confidence", type=float, required=True, help="TransferConfidence reportado por LAB."
    )
    p_lab_probe_complete.add_argument("--notes-json", help="JSON con notas/review opcional.")
    p_lab_probe_complete.set_defaults(func=cmd_lab_probe_complete)
    p_lab_probe_apply = lab_sub.add_parser(
        "probe-apply", help="Ejecuta un recipe aprobado (LAB_PROBE) en PROD."
    )
    p_lab_probe_apply.add_argument("--probe", required=True, help="ID o ruta del probe.")
    p_lab_probe_apply.add_argument(
        "--dry-run", action="store_true", help="No actúa físicamente (dry-run)."
    )
    p_lab_probe_apply.set_defaults(func=cmd_lab_probe_apply)

    p_display = sub.add_parser("display", help="Calibración y diagnóstico de displays.")
    display_sub = p_display.add_subparsers(dest="display_cmd", required=True)
    p_display_list = display_sub.add_parser("list", help="Lista displays disponibles.")
    p_display_list.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_display_list.add_argument("--driver-url", help="Override URL del driver.")
    p_display_list.add_argument("--json", action="store_true", help="Salida JSON.")
    p_display_list.set_defaults(func=cmd_display_list)
    p_display_cal = display_sub.add_parser("calibrate", help="Calibra dummy/primary.")
    p_display_cal.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_display_cal.add_argument("--driver-url", help="Override URL del driver.")
    p_display_cal.add_argument("--dummy-id", help="ID del dummy (LAB).")
    p_display_cal.add_argument("--prod-id", help="ID del primary (PROD).")
    p_display_cal.set_defaults(func=cmd_display_calibrate)
    p_display_diag = display_sub.add_parser("diag", help="Diagnóstico de displays.")
    p_display_diag.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_display_diag.add_argument("--driver-url", help="Override URL del driver.")
    p_display_diag.add_argument("--timeout", type=float, default=15, help="Timeout por captura.")
    p_display_diag.add_argument(
        "--black-threshold",
        type=float,
        default=5.0,
        help="Umbral de varianza para detectar imagen negra.",
    )
    p_display_diag.set_defaults(func=cmd_display_diag)

    p_desktop = sub.add_parser("desktop", help="Acciones de escritorio (observabilidad).")
    desktop_sub = p_desktop.add_subparsers(dest="desktop_cmd", required=True)
    p_desktop_snap = desktop_sub.add_parser("snap", help="Captura del escritorio.")
    p_desktop_snap.add_argument(
        "--active-window", action="store_true", help="Captura solo la ventana activa."
    )
    p_desktop_snap.add_argument(
        "--attach-to", choices=["mission", "job"], help="Adjuntar a la mision/job en espera."
    )
    p_desktop_snap.add_argument(
        "--display",
        help="Override display (id|dummy|primary|lab|prod).",
    )
    p_desktop_snap.add_argument(
        "--rail",
        choices=["lab", "prod"],
        help="Rail para seleccionar display por defecto.",
    )
    p_desktop_snap.add_argument("--mission-id", help="Mission id opcional.")
    p_desktop_snap.add_argument("--job-id", help="Job id opcional.")
    p_desktop_snap.set_defaults(func=cmd_desktop_snap)

    p_doctor = sub.add_parser("doctor", help="Diagnósticos operativos.")
    doctor_sub = p_doctor.add_subparsers(dest="doctor_cmd", required=True)
    p_doctor_drivers = doctor_sub.add_parser(
        "drivers", help="Lista quién está escuchando en 5010/5011."
    )
    p_doctor_drivers.set_defaults(func=cmd_doctor_drivers)
    p_doctor_anchor = doctor_sub.add_parser(
        "anchor", help="Valida ancla fisica rail+session+port+display."
    )
    p_doctor_anchor.add_argument("--rail", choices=["lab", "prod"], help="Rail objetivo.")
    p_doctor_anchor.set_defaults(func=cmd_doctor_anchor)
    p_doctor_providers = doctor_sub.add_parser(
        "providers", help="Self-test rápido de proveedores Brain."
    )
    p_doctor_providers.add_argument(
        "--roles", nargs="*", default=["brain"], help="Roles a probar (default: brain)."
    )
    p_doctor_providers.add_argument(
        "--incident", action="store_true", help="Abrir INCIDENT automatically si hay fallos."
    )
    p_doctor_providers.add_argument(
        "--explain",
        action="store_true",
        help="Explica por provider el estado y exclusion del Starting XI (premium).",
    )
    p_doctor_providers.set_defaults(func=cmd_doctor_providers)
    p_doctor_provider = doctor_sub.add_parser(
        "provider", help="Alias de `doctor providers` (singular)."
    )
    p_doctor_provider.add_argument(
        "--roles", nargs="*", default=["brain"], help="Roles a probar (default: brain)."
    )
    p_doctor_provider.add_argument(
        "--incident", action="store_true", help="Abrir INCIDENT automatically si hay fallos."
    )
    p_doctor_provider.add_argument(
        "--explain",
        action="store_true",
        help="Explica por provider el estado y exclusion del Starting XI (premium).",
    )
    p_doctor_provider.set_defaults(func=cmd_doctor_provider_alias)
    p_doctor_bridge = doctor_sub.add_parser(
        "bridge", help="Diagnóstico rápido de bridges CLI (gemini/qwen)."
    )
    p_doctor_bridge.add_argument("--providers", nargs="*", help="Filtra providers CLI específicos.")
    p_doctor_bridge.add_argument(
        "--timeout", type=float, default=6.0, help="Timeout por probe (segundos)."
    )
    p_doctor_bridge.set_defaults(func=cmd_doctor_bridge)
    p_doctor_leann = doctor_sub.add_parser(
        "leann", help="Verifica LEANN (keys, indice, query base)."
    )
    p_doctor_leann.set_defaults(func=cmd_doctor_leann)
    p_incident = sub.add_parser("incident", help="Gestión manual de incidentes.")
    incident_sub = p_incident.add_subparsers(dest="incident_cmd", required=True)
    p_incident_open = incident_sub.add_parser(
        "open", help="Abre un INCIDENT con adjuntos opcionales."
    )
    p_incident_open.add_argument(
        "--kind", required=True, help="Tipo de incidente (ej. provider_health)."
    )
    p_incident_open.add_argument("--summary", default="", help="Resumen breve.")
    p_incident_open.add_argument(
        "--remediation",
        action="append",
        default=[],
        help="Paso de remediación sugerido (puede repetirse).",
    )
    p_incident_open.add_argument(
        "--attach-last-doctor",
        action="store_true",
        help="Adjuntar el snapshot doctor más reciente.",
    )
    p_incident_open.set_defaults(func=cmd_incident_open)

    p_crystallize = sub.add_parser("crystallize", help="Pipeline: misión → episodio → recipe.")
    crys_sub = p_crystallize.add_subparsers(dest="crystallize_cmd", required=True)
    p_crystallize_mission = crys_sub.add_parser(
        "mission", help="Genera Episode + Candidate Recipe desde una misión."
    )
    p_crystallize_mission.add_argument("mission_id", help="ID de misión (mission-xxxx).")
    p_crystallize_mission.set_defaults(func=cmd_crystallize_mission)
    p_crystallize_auto = crys_sub.add_parser(
        "auto", help="Activa o desactiva auto-crystallize tras cada misión."
    )
    p_crystallize_auto.add_argument("mode", choices=["on", "off"], help="Estado deseado (on/off).")
    p_crystallize_auto.set_defaults(func=cmd_crystallize_auto)

    p_validate = sub.add_parser("validate", help="Valida recipes antes de promover hábitos.")
    val_sub = p_validate.add_subparsers(dest="validate_cmd", required=True)
    p_validate_recipe = val_sub.add_parser(
        "recipe", help="Ejecuta validación off-line sobre un recipe."
    )
    p_validate_recipe.add_argument("recipe", help="Recipe ID o ruta a recipe_*.json.")
    p_validate_recipe.add_argument(
        "--n", type=int, default=3, help="Máximo de evidencias a incluir en el informe."
    )
    p_validate_recipe.add_argument(
        "--source",
        choices=["episodes", "replay"],
        default="episodes",
        help="Fuente de evidencia: episodios históricos o replay en LAB (opcional).",
    )
    p_validate_recipe.add_argument(
        "--since", help="Epoch/ISO8601: filtra episodios recientes.", default=None
    )
    p_validate_recipe.add_argument(
        "--min-signals", type=int, default=None, help="Mínimo de señales observadas por episodio."
    )
    p_validate_recipe.add_argument(
        "--rail", choices=["lab", "prod"], default=None, help="Filtra episodios por rail."
    )
    p_validate_recipe.set_defaults(func=cmd_validate_recipe)

    p_promote = sub.add_parser("promote", help="Promociona recipes a hábitos canon.")
    promo_sub = p_promote.add_subparsers(dest="promote_cmd", required=True)
    p_promote_recipe = promo_sub.add_parser("recipe", help="Promueve un recipe ya validado.")
    p_promote_recipe.add_argument("recipe", help="Recipe ID o ruta a recipe_*.json.")
    p_promote_recipe.set_defaults(func=cmd_promote_recipe)
    p_promote_eligible = promo_sub.add_parser(
        "eligible", help="Valida (episodes) y promueve recipes elegibles."
    )
    p_promote_eligible.add_argument(
        "--since", help="Epoch/ISO: solo recipes más recientes que este instante.", default=None
    )
    p_promote_eligible.add_argument(
        "--min-signals", type=int, default=None, help="Mínimo de señales observadas por episodio."
    )
    p_promote_eligible.add_argument(
        "--runs", type=int, default=2, help="Episodios máximos a considerar por recipe."
    )
    p_promote_eligible.add_argument(
        "--limit", type=int, default=None, help="Máximo de recipes a procesar."
    )
    p_promote_eligible.add_argument(
        "--rail", choices=["lab", "prod"], default=None, help="Filtra episodios por rail."
    )
    p_promote_eligible.set_defaults(func=cmd_promote_eligible)

    p_research = sub.add_parser(
        "research", help="Lanza una tarea de investigación externa (The Scout)."
    )
    p_research.add_argument("topic", nargs=argparse.REMAINDER, help="Tema de investigación.")
    p_research.add_argument("--context", "-c", default="", help="Contexto adicional.")
    p_research.set_defaults(func=cmd_research)

    p_inspect = sub.add_parser("inspect", help="Resumen de misiones recientes (Inspector).")
    p_inspect.add_argument(
        "--last", "-n", type=int, default=50, help="Número de misiones a revisar."
    )
    p_inspect.add_argument(
        "--drivers", action="store_true", help="Incluir resumen de fallos del driver."
    )
    p_inspect.set_defaults(func=cmd_inspect)

    p_ingest = sub.add_parser(
        "leann-ingest-history", help="Ingesta ajax_history (export raíz) en LEANN."
    )
    p_ingest.add_argument(
        "--config", type=Path, default=None, help="Ruta alternativa al JSON de config."
    )
    p_ingest.set_defaults(func=cmd_leann_ingest_history)

    p_voice = sub.add_parser("voice-session", help="Inicia una sesión de voz (ASR+TTS) con AJAX.")
    p_voice.set_defaults(func=cmd_voice_session)

    p_marca_start = sub.add_parser(
        "marcapasos-start", help="Inicia Heartkeeper (supervisor de latido)."
    )
    p_marca_start.add_argument(
        "--interval", type=float, default=30.0, help="Intervalo entre ciclos (s)."
    )
    p_marca_start.add_argument(
        "--escalate-after", type=int, default=3, help="Ciclos rojos antes de escalar."
    )
    p_marca_start.add_argument(
        "--max-cycles", type=int, default=None, help="Máximo de ciclos (opcional, test)."
    )
    p_marca_start.set_defaults(func=cmd_marcapasos_start)

    p_marca_stop = sub.add_parser("marcapasos-stop", help="Detiene Heartkeeper.")
    p_marca_stop.set_defaults(func=cmd_marcapasos_stop)

    p_exp = sub.add_parser("experiment", help="THE AJAX PROTOCOL (experiments).")
    p_exp_sub = p_exp.add_subparsers(dest="experiment_cmd", required=True)
    p_exp_run = p_exp_sub.add_parser("run", help="Run an experiment envelope.")
    p_exp_run.add_argument("envelope", help="Path to envelope JSON.")
    p_exp_run.add_argument("--promote-task", default=None, help="Task name to promote on PASS.")
    p_exp_run.add_argument(
        "--allow-promotion",
        action="store_true",
        help="Allow tasks_registry.yaml update when PASS.",
    )
    p_exp_run.set_defaults(func=cmd_experiment_run)

    p_permit = sub.add_parser(
        "permit", help="HUMAN_PERMISSION TTL para acciones físicas (pixel-safety)."
    )
    p_permit.add_argument(
        "seconds", nargs="?", type=int, default=120, help="TTL en segundos (por defecto 120)."
    )
    p_permit.add_argument("--status", action="store_true", help="Muestra el estado del permiso.")
    p_permit.add_argument(
        "--revoke", action="store_true", help="Revoca el permiso (borra el flag)."
    )
    p_permit.set_defaults(func=cmd_permit)

    p_gaps = sub.add_parser("gaps", help="Gap utilities (LAB-only).")
    p_gaps_sub = p_gaps.add_subparsers(dest="gaps_cmd", required=True)
    p_gaps_triage = p_gaps_sub.add_parser("triage", help="Rank gaps and suggest probes.")
    p_gaps_triage.add_argument("--top", type=int, default=5, help="Number of gaps to include.")
    p_gaps_triage.add_argument(
        "--rail",
        choices=["lab", "prod"],
        default="lab",
        help="Rail selector (LAB-only).",
    )
    p_gaps_triage.set_defaults(func=cmd_gaps_triage)

    p_mv = sub.add_parser("motivo-vital", help="Calcula y muestra el Motivo Vital (MV) actual.")
    mv_sub = p_mv.add_subparsers(dest="mv_cmd", required=True)
    p_mv_status = mv_sub.add_parser(
        "status", help="Calcula MV y lo persiste en artifacts/motivo_vital/."
    )
    p_mv_status.set_defaults(func=cmd_motivo_vital)

    p_report = sub.add_parser("report", help="Genera un reporte diario (Gym + Heartbeat + MV).")
    p_report.set_defaults(func=cmd_report)

    args = parser.parse_args(argv)
    if args.command == "health":
        _check_ajax_history_notice()
    return args.func(args)


def cmd_motivo_vital(args: argparse.Namespace) -> int:
    if compute_motivo_vital is None or persist_mv is None:
        print("Motivo Vital no disponible (agency.motivo_vital no importable).", file=sys.stderr)
        return 3
    res = compute_motivo_vital()
    persist_mv(res)
    print(json.dumps(res.to_dict(), ensure_ascii=False, indent=2))
    return 0


def cmd_report(args: argparse.Namespace) -> int:
    try:
        from agency.reporting.daily_report import build_daily_report, persist_report, _load_json
    except Exception as exc:
        print(f"Reporte no disponible: {exc}", file=sys.stderr)
        return 3
    heartbeat = _load_json(ROOT / "artifacts" / "health" / "ajax_heartbeat.json") or {}
    gym = _load_json(ROOT / "artifacts" / "exercises" / "gym_daily.json") or {}
    report = build_daily_report()
    persist_report(report, heartbeat or {}, gym or {})
    print(report)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
